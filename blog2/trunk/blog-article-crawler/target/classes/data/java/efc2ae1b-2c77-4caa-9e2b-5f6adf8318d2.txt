探索 java 无 反射 机制 如何 节省 启动 内存 资源 消耗 随着 java 更新 的 新 特性 例如 体系结构 决策 及其 要求 当前 云 计算 通常 要求 应用程序 除了 初始 内 存量 少 之外 还要 拥有 更好 的 启动 性 因此有 必要 重新 设计 框架 的 制作 方式 以 消除 反射 的 瓶颈 在 框架 中 反 射在 发挥 着 重要作用 无论是 经典 的 orm 还是 jaxrs 之类 的 restapi 通过 大量 的 减少 各种 操 从 而使 javaer 的 工作 变得 更 轻松 对于 终端用户 这里 指的是 使用 这些 框架 的 用户 整个 过程 只需 在 类 中 添加 一些 符号 所有 操作 即可 正常 运行 它们 的 类 元 数据 将被 读取 并 用于 促进 某些 进程 当前 执行 这种 类型 的 最 流行 的 方法 是 通过 内省 从 而使 java 的 动态 语言 概念 轻而易举 地 生产 出来 由于 创 建了 大量 资源 并 提供 了 此类 工作 的 示例 和 文档 因此在 框架 内 使用 反射 api 简 化了 此类 工作 但是 由于 某些 原因 我们 在这里 讨论 两个 问题 启动 应用程序 延迟 和 内存 消耗 启动 应用程序 延迟 所有 处理 和 数据结构 将在 执 行时 执行 想象 一下 一个 依赖 项 注入 引擎 它 需要 逐级 扫描 检查 范围 依赖 项 等等 因此 需要 分析 的 类别 越多 所需 的 处理 就 越多 并且 大大 的 增加 响应 时间 内存 消耗 每个 类 都 需要 遍历 以 在 class 中 搜索 元 数据 有 一个 reflectiondata 缓存 加载 了 该类 的 所有 信息 即 搜索 诸如 getsimplename 之类 的 简单 信息 所有 元 数据 信息 都将 通过 softreference 加载 和 引用 这 需要 花费 一些 时间 才 能从 内存 中 取出 总之 反射 方法 在 初始 内存 消耗 和 启动 应用程序 延迟 都 存在 问题 这是 因为 在 应用程序 启动 后 就 立即 执行数 据分析 和 解析器 处理 随着 类 数量 的 增加 内存 和 运行时 消耗 趋于 增加 解决 这些 问题 的 方法 是 使 框架 在 编译 时而 不是 在运 行时 执行 这些 操作 当 应用程序 启动时 元 数据 和 系统 将 准备就绪 无需 调用 反射 类 包括 reflectiondata 从而 减 少了 启动时 的 内存 消耗 无需 担心 typeerasure 的 影响 避免 反射 的 另一 点 是 我们 可以 更 轻松 地 使用 aot 并 通过 graalvm 创建 本机 代码 这是 一个 令人兴奋 的 可能性 尤其是 对于 无 服务器 概念 该 程序 运行 一次 然后 将 整个 资源 返回 给 操作系统 演示 代码 在 解释 了 读数 类型 的 概念 后下 一步 将是 创建 一个 简单 的 工具 该 工具 将 java 类 从 某些 表示 将要 映射 的 实体 的 表示 法 转 换为 map 将被 转换 的 属性 以及 将是 唯一 标识符 的 字段 让我们 按照 下面 的 代码 所示 执行 所有 操作 elementtypetype retention retention retention default 为了 简化 与 反射 或 其他 选项 的 比较 将 创建 一个 接口 该 接口 负责 与 map 的 相互 转换 tentity 为了 比较 这两种 解决方案 第一个 实现 将是 通过 反射 实现 的 一点 是 有 几种 处理 反射 的 策略 例如 结合 使用 带有 introspector 的 javabeans 包 但是 在此 示例 中 我们 将以 最 简单 的 方式 进行 操作 以 展示 其 工作 原理 t for write tentity entityclass orelsethrow isblank annotationvalue mapput entityname for tryread entitymapfield catch idclass columnclass if idnull isblank true entity mapput idnamevalue elseif columnnull isblank true entity mapput columnnamevalue idclass columnclass if idnull isblank true idname if valuenull fieldset instancevalue elseif columnnull isblank true columnname if valuenull fieldset instancevalue 构 建了 映射器 之后 下一步 就是 做一个 小 例子 因此 让我们 创建 一个 animal 实体 entity animal nativename publicanimal stringid stringname idlion animal animalmapget entity idmapget id lionmapget nativename mapput idid mapput nativenamelion mapanimalclass idanimalgetid 这样 就 演示 了 反射 实现 的 实现 如果 希望 在其 他 项目 中 使用 这种 类型 的 工具 则 可以 创建 一个 小 项目 并 像 添加 其他 依赖 项 一样 而且 这些 操 作和 读取 都将 在运 行时 执行 要注意 的 是 在 反射 中有 一些 选项 和 策略 可以 使 用它 例如 创建 这些 元 数据 的 内部 缓存 以 避免 不断 使用 reflectiondata 或 从此 信息 中 避免 在 执 行时 编译 类 但是 最 重要 的 是 整个 过程 将在 执 行时 发生 为了 使 处理 移至 编译 我们 将 使用 要在 流程 中 成为 实体 的 类 需要 扩展 类 使用 批注 定义 在 编译 时 将 读取 哪些 类 以及 定义 代码 核心 的 流程 方法 此 方法 将 执行 所有 分析 最后 一步 是 将 该类 注册 为 spi 并且 代码 将在 编译 时 准备 运行 for annotation stream map eprocessingenv map filter isnotblank foreach entitiesadd tryif entitiesisempty entities catch error exception returnfalse 重要 的 一点 是 java 批注 处理 的 配置 比 反射 需要 更多 的 配置 步骤 但是在 开始 的 步骤 中 后续 步骤 往往 与 反射 api 相似 可以 通过 pomxml 文件 中 的 标记 来 完成 对此 库 类型 的 依赖 一个 很大 的 优点 是 这些 依赖 项 仅在 编译 范围内 可见 也就是说 可以 添加 依赖 项 来 生成 类 例如 使用 mustache 而 不必 担心 这些 依赖 项 在运 行时 将 依赖 项 添加到 项 目中 并 执行 后 将在 文件夹 内 生成 类 在 该 示例 中所 有 类 的 生 成都 归功于 mustache 项目 generated thisentitiesadd thisentitiesadd thisentitiesadd 通常 此 库 的 最终用户 的 功能 不会有 太大 变化 因为 用户 将 继续 在 实体 中 进行 注释 但是 所有 处理 逻辑 都 已被 带 到了 编译 时 entity animal nativename publicanimal stringid stringname idlion animal animalmapget entity idmapget id lionmapget nativename mapput idid mapput nativenamelion mapanimalclass idanimalgetid 以上 我们 讨论 了 反 射中 的 优点 和 缺点 用 java 注释 处理器 介绍 了 一个 示例 并 展示 了 javaaot 的 优势 并 将其 转 换为 本机 每种 选择 都会 产生 不利条件 删除 应用程序 时 所有 的 jit 优化 都会 丢失 并且 已 存在 的 一种 说法 随着 技术 的 发展 jvm 将比 本机 代码 更加 高效 性能 的 定义 非常复杂 并且 不仅仅 考虑 应用程序 启动 时间 你 需 不需要 一个 充满 技术 氛围 的 学习 交流 群 扫 码 就行 