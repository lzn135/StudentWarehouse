android jetpack 高手 日志 livedata 从 入门 到 精通 背景 上篇 介绍 了 androidjetpack 的 基础 组件 lifecycle 它是 生命周期 感知 型 组件 实现 生命周期 管理 的 一致性 在内部 进行了 统一 的 生命周期 状态 管理 可以 很 方便 的 提供给 其他 的 组件 比如 使用 同时 其他 类 还 能够 通过 实现 接口 和 添加 注解 来 监控 组件 的 生命周期 状态 达到 一个 解 耦 的 目的 livedata 是 一种 可 观察 的 数据 存储器 类 与 常规 的 可 观察 类 不同 livedata 具有 生命周期 感知 能力 意指 它 遵循 其他 应用 组件 如 的 生命周期 这种 感知 能力 可 确保 livedata 仅 更新 处于 活跃 生命周期 状态 的 应用 组件 观察者 也就是说 livedata 它 既是 一个 观察者 观察 生命周期 也是 一个 被 观察者 数据 变更 进行 通知 但是 数据 通知 只 发生 在 生命周期 活跃 状态 startedresumed 基础 使用 导入 依赖 因为 这两者 通常 都 一起 使用 使用 创建 livedata 的 实例 以 存储 某种 类型 的 数据 这 通常在 viewmodel 类 中 完成 创建 可定义 onchanged 方法 的 observer 对象 该 方法 可以 控制 当 livedata 对象 存储 的 数据 更改 时会 发生 什么 通常情况下 您 可以 在 界面 控制器 如 activity 或 fragment 中 创建 observer 对象 使用 observe 方法 将 observer 对象 附 加到 livedata 对象 observe 方 法会 采用 lifecycleowner 对象 这样 会使 observer 对象 订阅 livedata 对象 以 使其 收到 有关 更改 的 通知 通常情况下 您 可以 在 界面 控制器 如 activity 或 fragment 中 附加 observer 对象 代码 如 下在 viewmodel 中 定义 在 nameactivity 中 使用 superoncreate 观察 数据 更新 数据 anothername 您 必须 调用 setvalue t 方法 以 从 主 线程 更新 livedata 对象 如果 非 主 线程 中 执行 代码 您 可以 改用 postvalue t 方法来 更新 livedata 对象 将 livedata 与 room 一起 使用 room 持久性 库 支持 返回 livedata 对象 的 可 观察 查询 可 观察 查询 属于 数据库 访问 对象 dao 的 一部 分当 数据库 更新 时 room 会 生成 更新 livedata 对象 所需 的 所有 代码 在 需要 时 生成 的 代码 会在 后台 线程 上 异步 运行 查询 此 模式 有助于 使 界面 中 显示 的 数据 与 存储 在 数据库 中 的 数据 保持 同步 您 可以 在 room 持久性 库 指 南中 详细 了解 room 和 dao 将 协 程 与 livedata 一起 使用 livedata 支持 kotlin 协 程 如需 了解 详情 请参阅 将 kotlin 协 程 与 android 架构 组件 一起 使用 其实 google 推出 的 这一 系列 androidjetpack 库 在 不同 库 之间 的 配合 已经 做的 非常 好了 比如 上面 的 livedata 和 room 协 程 一起 使用 配合起来 如丝 般 顺滑 非常 好用 进阶 使用 扩展 livedata 如果 观察者 的 生命周期 处于 started 或 resumed 状态 则 livedata 会 认为 该 观察者 处于 活跃 状态 以下 示例 代码 说明 了 如何 扩展 livedata 类 symbolstring symbol listener listener 当 livedata 对象 具有 活跃 观察者 时会 调用 onactive 方法 这 意味着 您 需要 从此 方法 开始 观察 股价 更新 当 livedata 对象 没有 任何 活跃 观察者 时会 调用 oninactive 方法 由于 没有 观察者 在 监听 因此 没有 理由 与 stockmanager 服务 保持 连接 setvalue t 方法 将 更新 livedata 实例 的 值 并将 更改 告知 活跃 观察者 observe 方法 将与 fragment 视图 关联 的 lifecycleowner 作为 第一个 参数 传递 这样 做 表示 此 观察者 已 绑定 到 与 所有者 关联 的 lifecycle 对象 这 意味着 如果 lifecycle 对象 未 处于 活跃 状态 那么 即使 值 发生 更改 也 不会 调用 观察者 销毁 lifecycle 对象 后会 自动 移除 观察者 livedata 具有 生命周期 感知 能力 也就是说 可以 在 多个 之间 共享 这些 对象 所以 可以 将其 设置 为 单 例 转换 livedata 如果 你 希望 将 livedata 分 派给 观察者 之前 对 其 值 进行 修改 或者说 另一个 livedata 需要 根据 它 做 进一步 处理 lifecycle 包 中 的 transformation 类 可 以为 我们 提供 帮助 对 存储 在 livedata 对象 中 的 值 应用 函数 并将 结果 传 播到 下游 userlivedata 如果 想要 根据 某个 值 切换 观察 不同 livedata 数据 则可 以 使用 方法 两个 livedata 由 livedataswitch 决定 返回 哪个 livadata 数据 切换 条件 的 value 是 切换 条件 由 switchmap 方法 生成 用于 添加 观察者 booleaninput 这里是 具体 切换 逻辑 根据 livedataswitch 的 value 返回 哪个 livedataif input strings logi tagonchangeds switchvalue 设置 切换 条件 值 livedata livedata 这个 官方 的 demo 没看 明白 引用 的 是 胡 飞 洋 大佬 博客 文章内容 上面 的 很 多用 例 都是 官方 的 因为 在我看来 官方 的 用 例 是 最好 的 合并 多个 livedata 源 是 livedata 的 子类 允许 您 合并 多个 livedata 源 只要 任何 原始 的 livedata 源 对象 发生 更改 就会 触发 对象 的 观察者 比如 一个 常见 的 功能 app 内 的 通知 常用 小红点 显示 是否 有 新消息 这个 时候 如果 没有 对 红点 的 展示 逻辑 做一个 统一 的 抽象 和 管理 的话 就会 感觉 很 复杂 后续 也 不太好 维护 这个 时候 就可以 需要 进行 对 红点 的 统一管理 详细 内容 可以 参考 这篇 文章 源码 分析 我们 知道 livedata 是 在 lifecycle 的 帮助 下 实现 了 生命周期 管理 的 一致性 对于 livedata 的 数据 修改 流程 我们 从 setvalue 方法 开始 分析 tvalue setvalue null 然后 进入 方法 weakeraccess if initiatornull considernotify initiator iteratorhasnext considernotify iteratornext getvalue if breakwhile 因为 传入 的 的 参数 为 null 所以 我们 进入 considernotify 方法 if observermactive false returnif t mdata 可以 看到 在 最后 一行 被 观察者 通知 观察者 进行 onchanged 数据 变更 而 我们 的 订阅 是 在 observe 方法 中 observe 如果 lifecycleowner 的 getcurrentstate destroyed ignorereturn 包装 类 ownerobserver observerwrapper if owner if existingnull return 添加 观察者 的 真正 实 现是 activity 中 的 如果在 activity 中 调用 的话 addobserver wrapper 可以 看到 整个 流程 就是 这么 简单 就是 简单 的 观察者 模式 的 运用 不过 livedata 还 帮助 我们 自动 处理 的 生命周期 防止 内存 泄漏 要注意 的 是 除了 在 我们 主动 更新 数据 的 时候 会 触 发在 我们 的 观察者 状态 变更 的 时候 也 会 通知 到 这就 导致 了 livedata 必然 支持 粘性 事件 而 方法 是为了 将 数据 通知 到 主 线程 其中 postvalue 方法 最终 调 用了 tvalue mdatalock posttask 发送到 主 线程 实例 的 内容 如下 unchecked mdatalock t newvalue 最终 还是 调 用了 setvalue 方法 使用 livedata 的 优势 确保 界面 符合 数据 状态 livedata 遵循 观察者 模式 当 底层 数据 发生变化 时 livedata 会 通知 observer 对象 您 可以 整合 代码 以 在 这些 observer 对象 中 更新 界面 这样一来 您 无需 在 每次 应用 数据 发生变化 时 更新 界面 因为 观察者 会 替您 完成 更新 不会 发生 内存 泄漏 观察者 会 绑定 到 lifecycle 对象 并 在其 关联 的 生命周期 遭到 销毁 后 进行 自我 清理 不会 因 activity 停止 而 导致 崩溃 如果 观察者 的 生命周期 处于 非 活跃 状态 如 返回 栈 中 的 activity 则 它 不会 接收 任何 livedata 事件 不再 需要 手动 处理 生命周期 界面 组件 只是 观察 相关 数据 不会 停止 或 恢复 观察 livedata 将 自动 管理 所有这些 操作 因为 它在 观察 时 可以 感知 相关 的 生命周期 状态 变化 数据 始终保持 最新 状态 如果 生命周期 变为 非 活跃 状态 它 会在 再次 变为 活跃 状态 时 接收 最新 的 数据 例如 曾经在 后台 的 activity 会在 返回 前 台后 立即 接收 最新 的 数据 适当 的 配置 更改 如果 由于 配置 更改 如 设备 旋 转而 重新 创 建了 activity 或 fragment 它会 立即 接收 最新 的 可用 数据 共享资源 您可 以 使用 单 例 模式 扩展 livedata 对象 以 封装 系统 服务 以 便在 应用 中 共享 它们 livedata 对象连接 到 系统 服务 一次 然后 需要 相应 资源 的 任何 观察者 只需 观察 livedata 对象 如需 了解 详情 请参阅 扩展 livedata 基于 livedata 的 事件 总线 的 实现 livedatabus 可以 看出 livedata 本身 就 已经 可 观测 数据 更新 我们 通过 维护 一张 的 哈希 表 就可以 得到 一个 基础 的 事件 总线 channelstring channel channel channelstring channel jvmstaticfunget instance 除了 粘性 事件 以外 我们 还需要 非 粘性 事件 的 支持 这里有 两种 做法 反射 获取 在 订阅 的 时候 使得 初始化 的 等于 使得 粘性 消息 无法 通过 实现 这里 可以 参考 美 团 的 文章 android 消息 总线 的 演进 之路 用 livedatabus 替代 rxbuseventbus 还有 一种 做法 是 粘性 消息 最终 会 调到 那么 我们 就 干脆 将其 再 进行 一层 包装 内部 维护 实际 的 订阅 消息 数来 判断 是否 要 触发 真正 的 onchanged 方法 详细 内容 可以 参考 这篇 文章 livedata 的 建议 写法 在 我 自己 的 项 目中 我 通常 使用 该 方式 来 定义 livedata 严格控制 livedata 的 权限 确保 视图 中 只有 该 数据 的 访问 权限 而将 数据 的 修改 权限 严格 控制在 viewmodel 中 参考 自 github 上 的 一些 优秀 项目 的 写法 savebirthdayld 灵魂 拷问 在 activity 的 哪个 几个 生命周期 修改 livedata 值 能 被 观察者 观察到 前面 说 过 数据 变更 的 通知 控制在 生命周期 活跃 状态 startedresumed 那么 对 应是 哪几个 生命周期 呢 先来 看看 这段 代码 superoncreate setcontentview logi superonstart logi superonresume logi superonpause logi superonstop logi superondestroy logi 启动 界面 并 退出 界面 观察到 的 日志 是 状态 状态 状态 结果是 我们 只 能在 onstart onresume onpause 这三个 方法 中 而且 观察者 观察到 的 状态 都是 started 状态 注意 onstart 执 行时 是 created 状态 但是 收 到时 是 started 状态 那么 问题 又 来了 resumed 状态 呢 为什么 没有 呢 那么 resumed 状态 呢 我们 应该 怎么 获 取到 呢 我们 可以 在 ms 之后 获取 superonresume logi postdelayed runnablelogi tagonresume 毫秒 之后 获 取到 的 日志 如下 毫秒 之后 resumed 总结 如果 非 要用 一句话 来 总结 livedata 是 在 lifecycle 的 帮助 下 实现 了 生命周期 管理 的 一致性 将 数据 变更 的 通知 控制在 生命周期 活跃 状态 startedresumed 注意 这是 lifecycle 中 的 state 时 进行 通知 该 通知 成为 数据 的 唯一 可信 来源 也 就是 视图 获取 数据 的 唯一 入口 文末 jetpackcompose 是 谷歌 在 googleio 大会上 发布 的 新 的 库 是 用于 构建 原生 androidui 的 现代 工具包 他 有 强大 的 工具 和 直观 的 kotlinapi 简化 并 加速 了 android 上 的 ui 开发 可以 帮助 开发者 用 更少 更 直观 的 代码 创建 view 还有 更 强大 的 功能 以及 还能 提高 开发 速度 客观 地 讲 compose 确 实是 一套 比较 难学 的 东西 因为 它 毕竟 太 新 也 太大 了 它是 一个 完整 的 全新 的 框架 确实 让 很多人 感觉 学 不动 这 也是 个 事实 如果 你 是因为 缺少 学习 资料 而我 正好 薅 到 这本 谷歌 内部 大佬 根据 实战 编写 的 jetpackcompose 最全 上手 指南 从 入门 到 精通 教程 通俗易懂 实例 丰富 既有 基础知识 也有 进阶 技能 能够 帮助 读者 快速 入门 是 你 学习 jetpackcompose 的 葵花宝典 快收 藏起来 由于 篇幅 原因 如有 需要 以下 完整 学习 笔记 pdf 可以 点击 我 的 github 免费 下载 获取 第一章 初识 jetpackcompose 为什么 我们 需要 一个 新 的 ui 工具 jetpackcompose 的 着重点 加速 开发 强大 的 ui 工具 直观 的 kotlinapiapi 设计 composeapi 的 原则 一切都是 函数 顶层 函数 组合 优于 继承 信任 单一 来源 深入 了解 插槽 api 第二章 jetpackcompose 构建 最全 上手 指南 jetpackcompose 环境 准备 和 helloworld 布局 使用 materialdesign 设计 compose 布局 实时 预览 深入 详解 jetpackcompose 优化 ui 构建 compose 所 解决 的 问题 composable 函数 剖析 声明 式 ui 组合 vs 继承 封装 重组 深入 详解 jetpackcompose 实现 原理 composable 注解 意味着 什么 执行 模式 位置 记忆 化 存储 参数 重组 第三章 jetpackcompose 项目 实战 演练 附 应用 开始 前 的 准备 创建 demo 遇到 的 问题 jetpackcompose 应用 jetpackcompose 应用 做一个 倒 计时器 数据结构 倒计时 功能 状态 模式 compose 布局 绘制 时钟 用 jetpackcompose 写 一个 玩 安 卓 app 准备工作 引入 依赖 新建 activity 创建 画 页面 底部 导航 栏 管理 状态 添加 页面 用 composeandroid 写 一个 天气 应用 开篇 画 页面 画 背景 画 内容 用 compose 快速 打造 一个 电影 app 成品 实现 方案 实战 不足 由于 篇幅 原因 如有 需要 以上 完整 学习 笔记 pdf 可以 点击 我 的 github 免费 下载 获取 