android jetpack 高手 日志 viewmodel 从 入门 到 精通 背景 上 一篇 介绍 了 androidjetpack 组件 是 在 lifecycle 的 帮助 下 实现 了 生命周期 管理 的 一致性 将 数据 变更 的 通知 控制在 生命周期 活跃 状态 startedresumed 注意 这是 lifecycle 中 的 state 时 进行 通知 该 通知 成为 数据 的 唯一 可信 来源 也 就是 视图 获取 数据 的 唯一 入口 livedata 经常 和 viewmodel 一起 配合 使用 定义 下面 我们 来 介绍 下一个 androidjetpack 的 下一个 组件 viewmodel 先来 看 官方 的 定义 viewmodel 类 旨在 以 注重 生命周期 的 方式 存储 和 管理 界面 相关 的 数据 viewmodel 类 让 数据 可在 发生 屏幕 旋转 等 配置 更改 后 继续 留存 在我看来 viewmodel 类 让 数据 可在 屏幕 发生 等 配置 更改 后 继续 留存 比 如在 界面 因 配置 改变 重新 创建 后 viewmodel 依旧 持有 原先 的 数据 这个 功能 当然 很 重要 但 还有 一个 同样 重要 的 功能 是 在 fragment 之间 共享 数据 最后 由于 其 管理方式 单向 依赖 只有 持有 viewmodel 也 避免了 内存 泄漏 的 发生 同时 viewmodel 配合 kotlin 协 程 将 加载 器 替 换为 viewmodel 这些 也是 viewmodel 能 发挥 重要作用 的 地方 基本 使用 导入 依赖 因为 这两者 通常 都 一起 使用 简单 使用 androidjetpack 架构 组件 为 界面 控制器 提供 了 viewmodel 辅助 程序 类 该类 负责 为 界面 准备 数据 在 配置 更改 期间 会 自动 保留 viewmodel 对象 以便 他们 存储 的 数据 立即 可供 下一个 实例 使用 下面 来看 个 例子 viewmodel 代码 如下 useridstring logi 方法 s 后 获取 用户 信息 userid 赋值 superoncleared logi activity 代码 如下 superoncreate setcontentview ridtxtusername logi tagoncreate this get jackie thisobserver 通知 uiui 进行 操作 logi 点击 按钮 后 获取 用户 信息 执 行了 viewmodel 中 的 方法 配置 变化 后 屏幕 旋转 后 日志 打印 如下 可以 看到 activity 重新 创 建了 我们 并没有 点击 按钮 执行 loadusername 方法 但是 却 回 调了 observer 的 onchange 方法 而且 viewmodel 的 onclear 方法 并没有 执行 说明 viewmodel 并没有 销毁 重建 注意 viewmodel 的 创建 方式 使用 的 是 this get 而 不是 create tif fragment 间 数据 共享 activity 中 的 两个 或 更多 fragment 互相 通信 是 一种 很 常见 的 需求 假设 你 有 一个 fragment 在 该 fragment 中 用户 从 列表 中 选择 一项 还有 另一个 fragment 用于 显示 选定 项 的 内容 这种 情况 不太 容易 处理 因为 这两个 fragment 都 需要 定义 某种 接口 描述 并且 所有者 activity 必 须将 两者 绑定 在一起 此外 这两个 fragment 都必须 处理 另一个 fragment 尚未 创建 或 不可 见 的 情况 可以 使用 viewmodel 对象 解决 这个 常见 的 难点 这两个 fragment 可以 使用 其 activity 范围 共享 viewmodel 来 处理 此类 通信 代码 如下 funselect itemitem 这两个 fragment 都会 检索 包含 它们 的 activity 这样 当 这两个 fragment 各种 获取 时 他们 会 收到 相同 的 sharedviewmodel 实例 其 范围 限 定为 该 activity 此 方法 具有 以下 优势 activity 不需要 执行 任何 操作 也 不需要 对此 通信 有 任何 了解 除了 sharedviewmodel 约定 之外 fragment 不需要 相互了解 如果 其中 一个 fragment 消失 另一个 fragment 将 继续 照常 工作 每个 fragment 都有 自己 的 生命周期 而 不受 另一个 fragment 的 生命周期 的 影响 如果 一个 fragment 替换 另一个 fragment 界面 将 继续 工作 而 没有 任何问题 viewmodel 的 生命周期 viewmodel 对象 存在 的 时间 范围 是 获取 viewmodel 时 传 递给 的 lifecycle 也 就是 上面 我们 调用 的 代码 this get 这里 的 this 是 activity 实例 对象 因为 我们 的 activity 实现 了 lifecycle 的 关联 viewmodel 将 一直 留在 内存 中 直到 限定 其 存在 时间 范围 的 lifecycle 永久 消失 对于 activity 是 在 activity 完成 时而 对于 fragment 是 在 fragment 分离 时 下图 是 activity 在 屏幕 旋转 而后 结束时 所处 的 各种 生命周期 状态 该 图 还在 关联 activity 生命周期 的 旁边 显示 了 viewmodel 的 生命周期 这些 基本 状态 同样 适用于 fragment 的 生命周期 通常是 在 系统 首次 调用 activity 对象 的 oncreate 时 请求 存在 的 时间 范围 是 从 首次 请求 viewmodel 直到 activity 完成 并 销毁 源码 分析 在 分析 源码 前 我 先 提出 两个 问题 viewmodel 是 如何 做到 让 数据 可在 发生 屏幕 旋转 等 配置 更改 后 继续 留存 也就是说 viewmodel 实例 依然 存在 fragment 之间 是 如何 通过 viewmodel 共享 数据 的 先来 看看 viewmodel 类 该 方法 将 会在 viewmodel 被 清除 时 调用 可以 在 这个 方法 里 做 一些 取消 注册 防止 内存 泄漏 weakeraccess viewmodel 只是 一个 抽象类 clear 方法 会在 viewmodel 被 清除 时 调用 有 用户 可以 通过 重写 oncleared 方法来 处理 一些 额外 的 操作 再从 调 用处 开始 分析 this get 我们 再来 看看 这个 类 this owner this factory 最终 调 用到 的 构造 器 都是 第三个 构造 器 再来 看看 viewmodelstore 和 factory 是什么 因为 我们 传入 的 是 activity 是 和 的 实现 者 所以 才会 有 第二个 参数 是 可以 理解为 存储器 的 拥有 者 也就是说 我们 的 是 viewmodel 存储器 的 拥有 者 然后 我们 来看 看看 viewmodelstore 是什么 存储 finalvoidput keyviewmodel if stringkey returnmmapget key mmapkeyset for vmclear mmapclear 可以 看到 viewmodelstore 的 代码 很简单 就是 用 一个 hashmap 存储 了 key string 和 value viewmodel 这里 的 key 的 名字 为 key 的 名字 因为 第二个 参数 是 通过 获 取到 的 前面 说 过 activity 是 的 实现 类 我们 再来 看看 activity 中 的 方法 if getapplication null if getapplication thisgetintent nullgetintent getextras null 可以 看到 是 通过 一个 来 获取 命名 也 很 清晰 直观 就是 保存 状态 的 viewmodel 工厂 下面 我们 再来 看看 get 方法 if returnget key 的 名字 unchecked key 从 hashmap 中 获取 viewmodel 实例 if viewmodel if mfactory onrequery viewmodel return t viewmodelnull todologawarning 使用 factory 创建 if viewmodel keyedfactory mfactory create keymodelclass elseviewmodel mfactory create modelclass 存入 keyviewmodel return t viewmodel 简单 来说 就是 从 mviewmodelstore 获取 viewmodel 如果 没有 获 取到 就 使用 factory 创建 然后 存入 mviewmodelstore 这样 逻辑 就 清楚 了 this get 会把 viewmodel 存入 viewmodelstore 中 因为 activity 实现 了 接口 可以 理解为 存储器 的 拥有 者 也就是说 我们 的 是 viewmodel 存储器 的 拥有 者 然后 我们 来 看看 该 方法 在 activity 中 的 实现 if getapplication null if 从 获取 if ncnull 恢复 如果 还是 获取 不到 就 新建 一个 if 从 该 方法 中 可以 看到 内部 最 终会 创建 一个 viewmodelstore 用来 存储 viewmodel 接下来 我们 来看 方法 为什么 使用 方法 呢 我们 先来 看看 activity 状态 保存 和 恢复 和 的 使用 场景 区别 我们 知道 在 屏幕 旋转 的 时候 会 执行 保存 状态 和 恢复 状态 的 方法 bundleoutbundle 保存 outbundle 恢复 注意 如果 你 是 继承 该 方法 已经在 它 的 父 类 定义 为 final 子类 无法 重写 继承 activity 就可以 在这里 设置 需要 保存 的 内容 在 切换 时 不是 bundle 了 我们 可以 直接 通过 object 来 代替 在 android 他们 的 执行 顺序 都在 onstop 和 ondestory 之间 而且 比 先 执行 一般 情况 我们 保存 的 数据 不是 太大 适合 放在 bundle 中 这个 时候 使用 比较 合适 如果 要 保存 的 数据 不适合 放在 bundle 中比 如一 个 socket 或是 数据 比较 大 比如 bitmap 那么 这个 时间 我们 就应该 使用 而且 我们 使用 可以 保存 任何 类型 的 对象 像 asynctask 和 sqlitedatabse 我们 都可以 进行 保存 这些 类型 的 数据 可能 会被 一个 新 的 activity 重新 使用 也就是说 bundle 中 只能 放 一些 特定 的 类型 比如 基本 数据类型 数组 serialable 对象 而 中 只 要是 个 object 对象 就可以 了 同时 当 某个 activity 变得 容易 被 系统 销毁 时 该 activity 的 就会 被执行 而 更多 的 是 时候 是 在 配置 改变 时 操作 的 这个 时候 保存 一些 不会 因为 配置 改变 而 发生 改变 的 东西 而且 数据 是 序列化 保 存到 磁盘 中 而 保存 的 数据 是 存在 内存 中 所以 这里 我们 的 viewmodel 肯定是 放在 方法 中 再来 看看 if ncnull returnnull 新建 将 viewmodelstore 保存 可以 看到 在 该 方法 中 保存 了 viewmodelstore 保 存在 了 而 该 的 真正 实 现是 在 activityjava 类 中 activityjava 静态 内 部类 而 的 赋值 是 在 attach 方法 中 的 context 为什么 viewmodel 在 配置 变化 后 依旧 存在 而 attach 中 的 传入 的 参数 是 的 一个 变量 而 是 存在 activitythread 的 mactivities arraymap 中 activitythread 中 的 不受 activity 重建 的 影响 所以 activitythread 中 的 同样 也 不受 影响 所以 中 的 也无 影响 所以 viewmodelstore 不受 影响 最终 viewmodel 在 activity 重新 创建 后 调用 获取 得到 这 也是 viewmodel 一直 存在 的 原 因在 更早 之前 版本 保存 viewmodel 是 使用 holderfragment 的 fragment 中 的 boolean 在 设置 为 true 时 可 以是 当前 的 fragment 在 activity 重建 时 存储 下来 所以 可以 在 activity 中 注入 一个 fragment 这样 就可以 达到 保存 viewmodel 的 功能 了 详情 可以 参考 这篇 文章 fragment 之间 是 如何 通过 viewmodel 共享 数据 的 从上 面的 分析 我们 知道 viewmodel 存在 activity 的 viewmodelstore 中 多个 fragment 依赖于 同一个 activity 这个 时候 拿到 同一个 viewmodel 自然 就不是 问 题了 为什么 旋转 后 所有 的 livedata 会 重新 执行 一次 通知 原因 很简单 因为 livedata 的 事件 是 粘性 事件 也就是说 当 activity 销毁 后 因为 viewmodel 中 的 livedata 并没有 销毁 有 具体 的 值 在 activity 重新 创建 后 livedata 会 将该 值 发送给 当前 activity 界面 达到 恢复 activity 界面 状态 的 效果 viewmodel 如何 避免 内存 泄 漏在 的 构造 器 中 可以 看出 getlifecycle addobserver 添 加了 一个 观察者 观察 界面 是否 销毁 一旦 销毁 就 清空 viewmodelstore 中 的 所有 lifecyclenull getlifecycle if getlifecycle addobserver if nullif decornull getlifecycle addobserver if if clear 界面 执行 ondestroy 方法 是 清空 viewmodel if getlifecycle addobserver this viewmodel 和协 程 一起 使用 viewmodel 支持 协 程 viewmdoelscope 为 应用 中 的 每个 viewmodel 定义 了 viewmdoelscope 如果 viewmodel 已 清除 则 在此 范围内 启动 的 协 程 都会 自动 取消 如果您 具有 仅在 viewmodel 处于 活动 状态 时 才 需要 完成 的 工作 此时 协 程 非常 有用 例如 如果 要为 布局 计算 某些 数据 则 应将 工作范围 限定 至 viewmodel 以 便在 viewmodel 清除 后 系统 会 自动 取消 工作 以 避免 消耗 资源 的 这些 架构 组件 配合起来 会 非常 强大 大大 节省 开发者 的 开发 时间 同时 还能 轻松 避免 内存 泄漏 简直 就是 开发 利器 总结 viewmodel 是 个 非常 好用 的 androidjetpack 组件 可在 发生 屏幕 旋转 等 配置 更改 后 继续 留存 同时 还 能在 不同 fragment 之间 共享 在 配合 协 程 使 用时 也 非常 方便 还能 轻松 避免 内存 泄漏 需要 注意 的 是 不少 开发者 会将 viewmodel 实现 接口 把 viewmodel 当做 一个 能 感应 生命周期 变化 的 组件 在 感知 到 生命周期 的 方法 中 执行 loaddata 之类 的 操作 然后 通过 livedata 去 通知 ui 做出 对应 的 改变 这样 的 做法 丧失了 官 方为 我们 设计 的 viewmodel 的 初衷 反而 有点 不伦不类 了 而且 viewmodel 配合 协 程 也 非常 方便 也有 很多人 将 网络 请求 也 放到 viewmodel 去 调用 个人感觉 也是 很不 合适 的 可以 参考 官方 的 demo 进行 设计 文末 的话 最近 火热 的 jetpackcompose 是 谷歌 在 googleio 大会上 发布 的 新 的 库 是 用于 构建 原生 androidui 的 现代 工具包 他 有 强大 的 工具 和 直观 的 kotlinapi 简化 并 加速 了 android 上 的 ui 开发 可以 帮助 开发者 用 更少 更 直观 的 代码 创建 view 还有 更 强大 的 功能 以及 还能 提高 开发 速度 客观 地 讲 compose 确 实是 一套 比较 难学 的 东西 因为 它 毕竟 太 新 也 太大 了 它是 一个 完整 的 全新 的 框架 确实 让 很多人 感觉 学 不动 这 也是 个 事实 如果 你 是因为 缺少 学习 资料 而我 正好 薅 到 这本 谷歌 内部 大佬 根据 实战 编写 的 jetpackcompose 最全 上手 指南 从 入门 到 精通 教程 通俗易懂 实例 丰富 既有 基础知识 也有 进阶 技能 能够 帮助 读者 快速 入门 是 你 学习 jetpackcompose 的 葵花宝典 快收 藏起来 由于 篇幅 原因 如有 需要 以下 完整 学习 笔记 pdf 可以 点击 我 的 github 免费 下载 获取 第一章 初识 jetpackcompose 为什么 我们 需要 一个 新 的 ui 工具 jetpackcompose 的 着重点 加速 开发 强大 的 ui 工具 直观 的 kotlinapiapi 设计 composeapi 的 原则 一切都是 函数 顶层 函数 组合 优于 继承 信任 单一 来源 深入 了解 插槽 api 第二章 jetpackcompose 构建 最全 上手 指南 jetpackcompose 环境 准备 和 helloworld 布局 使用 materialdesign 设计 compose 布局 实时 预览 深入 详解 jetpackcompose 优化 ui 构建 compose 所 解决 的 问题 composable 函数 剖析 声明 式 ui 组合 vs 继承 封装 重组 深入 详解 jetpackcompose 实现 原理 composable 注解 意味着 什么 执行 模式 位置 记忆 化 存储 参数 重组 第三章 jetpackcompose 项目 实战 演练 附 应用 开始 前 的 准备 创建 demo 遇到 的 问题 jetpackcompose 应用 jetpackcompose 应用 做一个 倒 计时器 数据结构 倒计时 功能 状态 模式 compose 布局 绘制 时钟 用 jetpackcompose 写 一个 玩 安 卓 app 准备工作 引入 依赖 新建 activity 创建 画 页面 底部 导航 栏 管理 状态 添加 页面 用 composeandroid 写 一个 天气 应用 开篇 画 页面 画 背景 画 内容 用 compose 快速 打造 一个 电影 app 成品 实现 方案 实战 不 不足 由于 篇幅 原因 如有 需要 以上 完整 学习 笔记 pdf 可以 点击 我 的 github 免费 下载 获取 