并发 编程 1-jmm 解决 的 问题 线程 与 jvmjava 内存 区域 和 java 内存 模型 的 区别 硬件 内存 架构 与 java 内存 模型 java 内存 模型 对 并发 的 保证 基本概念 程序代码 完成 某一个 任务 或者 业务 的 代码 序列 比如 qq 进程 程序 在 某些 数据 上 的 一次 运行 比如 我 调用 一个 接口 这 就是 一个 进程 线程 一个 进程 包含 多个 线程 占有 资源 的 独立 单元 jvm 与 线程 jvm 什么时候 启动 类 被 调用 的 时候 会有 jvm 线程 执行 到 main 方法 的 时候 会 创建 main 进程 线程 是 存在于 jvm 中 jvm 的 内存 区域 方法 区 中 都是 共享 的 信息 方法 区 主要 放置 类 的 信息 由 classload 进行 加载 的 常量 staicjitjava 堆 区 也是 共享 的 信息 会 发生 oom 堆 区 存放 的 实例 变量 可见 垃圾处理 gc 会 常常 光顾 这片 区域 每个 线程 的 栈 都是 该 线程 私有 的 堆 则是 所有 线程 共享 的当 我们 new 一个 对象 时 该 对象 就被 分配 到了 堆 中 但是 堆 并不是 一个 简单 的 概念 堆 区 又 划 分了 很多 区域 为什么 堆 划 分成 这么多 区域 这是 为了 jvm 的 内存 垃圾 收集 似乎 越 扯 越 远了 扯到 垃圾 收 集了 现在 的 jvm 的 gc 都是 按 代 收集 堆 区 大致 被 分为 三大块 新生代 旧生 代 持久 代 虚拟 的 新生代 又 分为 eden 区 s 区 s 区 新建 一个 对象 时 基本 小 的 对象 生命 周期短 的 对象 都会 放在 新生代 的 eden 区 中 eden 区 满 时有 一个 小范围 的 gcminorgc 整个 新生代 满 时会 有 一个 大范围 的 gcmajorgc 将 新生代 里 的 部分 对象 转到 旧生 代 里 原文 链接 虚拟机 栈 会 发生 oom 虚拟机 栈 java 方法 运行 的 内存 模型 每一个 java 方法 都有 唯一 的 栈 帧 对应 不能实现 数据 共享 而且 每一个 栈 帧 的 容量 是 有限 的 在 方法 内 死循环 会 造成 oom 摘自 线程 的 每个 方法 被执行 的 时候 都会 同时 创建 一个 帧 frame 用于 存储 本地 变 量表 操作 栈 动态 链接 方法 出入口 等 信息 每一个 方法 的 调用 至 完 成就 意味着 一个 帧 在 vm 栈 中 的 入 栈 至 出 栈 的 过程 如果 线程 请求 的 栈 深度 大于 虚拟机 所 允许 的 深度 将 抛出 异常 如果 vm 栈 可以 动态 扩展 vmspec 中 允许 固定 长度 的 vm 栈 当 扩展 时 无法 申请到 足够 内存 则 抛出 异常 原文 链接 我们 可 以对 整个 虚拟机 栈 设置 大小 但是 栈 帧 的 大小 有 jvm 自己 根据 变量 数 等等 来 分配 不 可控 pc 程序 计数器 每一个 java 线程 都有 一个 程序 计数器 来 用于 保存 程序 执行 到 当前 方法 的 哪一个 指令 java 线程 的 私有 数据 这个 数据 就是 执行 下一 条 指令 的 地址 本地 方法 栈 java 内存 模型 共用 内存 共享 信息 工作 空间 私有 信息 每一个 线程 都有 自己 的 工作 空间 存放 自己 的 私有 信息 比如 保证 数据 的 不可 见性 基本 的 数据类型 直接 分 配到 工作 内存 中 引用 类型 的 地址 也 存放在 工作 空 间中 引用 的 对象 存放在 堆 中 工作 模式 a 线程 修改 私有 数据 直 接在 工作 空间 修改 b 线程 修改 共享 数据 先 读到 工作 空间 进行 修改 修改 完成后 刷新 内存 中 的 数据 jvm 内存 区域 就是 根据 jmm 来 设计 的 jmm 就是 一种 模型 思想 看不见 的 东西 相当于 一种 规范 这两个 可以 由 springmvcmvc 设计 思 想用 这种 思想 影响 操作 这里 的 工作 空间 可以 看成 vmstack 和 pc 他 的 作用 就是 规范 内存 数据 和 工作 空间数据 的 交互 硬件 内存 架构 与 java 内存 模型 java 内存 模型 为什么 可以 扯到 硬件 呢 因为 jvm 是 在 内存 中 运行 的 抛开 这个 不谈 现在 的 计算器 cpu 在 计算 的 时候 原始 的 数据 来自 内 存在 计算 过程中 有些 数据 可能 被 频繁 读取 这些 数据 被 存储 在 寄存器 和 高速缓存 中 当 线程 计算 完 后 这些 缓存 的 数据 在 适当 的 时候 应该 写回 内存 当个 多个 线程 同时 读写 某个 内存 数据 时 就会 产生 多线程 并发 问题 涉及到 三个 特性 原子 性 有序性 可 见性 下图 展示 硬件 的 内存 架构 与 上面 的 java 内存 模型 是不是 非常 相像 要看 他们 之间 共同点 java 内存 模型 中 的 共用 内存 就是 硬件 的 内存 线程 的 工作 空间 可 以是 寄存器 也 可 以是 缓存 或者 内存 因为 线程 的 数据 会 来自 缓存 和 内存 以及 寄存器 中 在 硬件 的 层 面上 如何 进行 加锁 呢 保证 线程 安全 总线 加锁 相当于 串行 安全 但是 降 低了 cpu 的 吞吐量 缓存 上 的 一致性 协议 mesi 当 cpu 在 寄存器 中 操作 数据 如果 该 数据 时 共享 变量 数据 在 修改 的 时候 cacheline 置 为 无效 其他 的 cpu 就从 内存 中 读取 数据 java 线程 与 硬件 处理器 的 关系 任务 过来 之 后会 从 线程 池 获取 一个 线程 线程 转 化为 一个 内核 线程 从而 操作 硬件 并发 编程 的 三个 重要 特性 原子 性 不可分割 比如 xx 不是 原子 性 的 因为 涉及到 多个 原子 性 的 操作 可 见性 线程 只能 操作 自己 工作 空间 的 数据 有序性 程序 的 顺序 不一定 就是 cpu 执行 的 顺序 一行 代码 在 cpu 看来 就是 多条 指令 cpu 为了 优化 程序 执 行会 进行 编译 时 指令 重排 序目 的 是 提高 效率 重 排序 需要 满足 两个 规则 asifseria 原 则在 单线程 中 重 排序 不影响 程序 运行 的 结果 happensbefore 原则 必须 等到 锁 释放 才能 访问 目标 资源 volatile 修饰 的 变量 这一 行 所在 的 代码 不会 重 排序 jmm 如何 保证 原子 性 什么 是 原子 性 x 写 gt 如果是 私有 数据 具有 原子 性 如果是 共享 数据 没 原子 性 读写 yx 没有 原子 性 把 数据 x 读到 工作 空间 原子 性 把 x 的 值 写到 y 原子 性 i 没有 原子 性 读 i 到 工作 空间 刷新 结果 到 内存 zz 没有 原子 性 读 z 到 工作 空间 刷新 结果 到 内存 如何 保证 原子 性 呢 与 可 见性 什么 是 可 见性 线程 修改 共享 数据 其他 线程 能够 感知 到 在 硬件 层面 上有 一个 mesi 协议 在 jmm 模型 上 同样 也有 类似 实现 了 mesi 协议 也 就是 volatile 被 volatile 修饰 的 变量 a 线程 读取 后 b 线程 要在 内存 中 获取 但是 如果 a 线程 没有 刷 新到 内存 中 b 线程 仍然会 读 取到 旧 值 synchronizedjuc 