aqs 是 如何 控制 线程 的 戳 蓝字 topcoder 关注 我们 哦 java 中 队列 同步器 是 构建 juc 中 锁 和 其他 同步 组件 的 基础 组件 我们 在 日常 开发 中 一般 不会 直接 与 aqs 打交道 aqs 核心 功能 就 点 通过 cas 维护 state 状态 通过 cas 维护 同步 队列 进而 控制 线程 的 阻塞 唤醒 换句话说 就是 aqs 使用 一个 int 成员 变量 表示 同步 状态 通过 内置 的 fifo 队列 来 完成 资源 获取 线程 的 排队 工作 并 发包 的 作者 douglea 期望 它 能够 成为 实现 大部分 同步 需求 的 基础 aqs 是 一个 抽象类 但是 并没有 抽象 方法 只不过 有些 方法 是 会 抛出 这些 方法 就需要 根据 不同 场景 进行 子类 重写 比如 可 重入 锁 就 重 写了 方法 等 子类 重写 这些 方法 可 自定义 对应 逻辑 比如 判断 是否 可 重入 是否 公平 设置 state 等 这块 具体 代码 参考 类 源码 即可 目前 aqs 的 实现 类 如下 所示 state 状态 更新 aqs 实现 类 中 必不可少 的 要对 同步 状态 state 进行 更改 如果 想 线程 安全 的 更新 数据 只有 通过 锁 或者 cas 机制 来 保证 由于 aqs 是 实现 锁 的 底层 组件 因此 这里 只能 使用 cas 机制 来 保证 aqs 确实 也是 这么 做的 aqs 提供 了 个 方法来 更新 状态 和 setstate intnewstate 后者 只有 在当 前 线程 是 状态 占用 线程 下 才能 被 调用 子类 推荐 被 定义 为 自定义 同步 组件 的 静态 内部 类 同步器 自身 没有 实现 任何 同步 接口 它 仅仅是 定义 了 若干 同步 状态 获取 和 释放 的 方法来 供 自定义 同步 组件 使用 同步器 既可以 支持 独占 式 地 获取 同步 状态 也 可以 支持 共享 式 地 获取 同步 状态 这样 就可以 方便 实现 不同 类型 的 同步 组件 和 countdownlatch 等 aqs 是 实现 锁 也 可 以是 任意 同步 组件 的 关键 在 锁 的 实现 中 聚合 同步器 利用 同步器 实现 锁 的 语义 可以 这样 理解 二者之间 的 关系 锁 是 面向 使用者 的 它 定义 了 使用者 与 锁 交互 的 接口 比如 可以 允许 两个 线程 并行 访问 隐藏 了 实现 细节 同步器 面向 的 是 锁 的 实现 者 它 简 化了 锁 的 实现 方式 屏蔽 了 同步 状态 管理 线程 的 排队 等待 与 唤醒 等 底层 操作 锁 和 同步器 很好 地 隔 离了 使用者 和 实现 者 所需 关注 的 领域 同步 队列 维护 如果 线程 更新 状态 tryacquire 成功 直接 返回 如果 更 细 状态 失败 则会 初始化 一个 当前 的 node 对象 cas 设置 到 同步 队列 tail 注意 队列 headtail 节点 是 懒 初始化 的 注意 添加 node 对象 到 同步 队列 中 还 不够 因为 可能 这个 时候 之前 占用 状态 的 线程 已经 释放 状态 了 或者 后续 占用 状态 的 线程 释放 时 应该 怎么 下一个 节点 线程 呢 这里 就 涉及到 再次 tryacquire 或者 设置 当前 阻塞 node 前 一个 node 的 waitstatus 具体 代码 可 参考 方法 最后 就是 调用 方法 locksupportpark this 来 阻塞 当前 线程 源码 分析 了 解了 aqs 的 state 和 同步 队列 后 下面 来 以 类 reentrantlock 中 fairsync 为 例 来 分析 aqs 流程 示例 代码 如下 stringargs newthread gtlocklock getname lockok lockunlock t start newthread gtlocklock getname lockok lockunlock t start locksupportpark fairsync 源码 如下 finalvoidlock acquire 尝试 获取 状态 intacquires intcgetstate if c cas 设置 stateif acquires current 可 重入 nextclt thrownewerror setstate nextc 操作 lock 操作 也 就是 执行 acquire 首先 尝试 获取 锁 成功 直接 返回 失败 初始化 一个 node 放入 阻塞 队列 然后 阻塞 自己 intarg 尝试 获取 锁 成功 直接 返回 失败 创建 node 放入 同步 队列 if tryacquire arg addwaiter nodeexclusive arg selfinterrupt addwaiter nodeexclusive 就是 将 初始化 的 nodecas 放到 tail 处 不再 赘述 重点 看下 acquirequeued 逻辑 如果 pre 是 头 节点 再次 尝试 获取 锁 if arg sethead node 否则 需要 变更 waitstatus 然后 阻塞 自己 等待 占用 state 的 线程 来 唤醒 自己 if pnode failed cancelacquire node node 的 waitstatus 有 以下 几种 类型 其中 要注意 signal 时 表示 当前 线程 需要 唤醒 下一个 阻塞 的 节点 线程 操作 unlock 操作 就是 lock 的 逆 操作 相对来说 比较简单 aqs 的 realase 源码 如下 intarg if tryrelease arg nodehheadif unparksuccessor h arg 就是 当前 state 重置 为 然后 判断 同步 队列 头 结点 如果 非 空 并且 waitstatus 则 进行 唤醒 下一个 节点 操作 源码 如下 nodenode wslt nodews 找到 下一个 可 以待 唤醒 的 节点 waitstatusgt 表示 当前 线程 已经 处于 唤醒 状态 了 比如 异常 或者 等待 超时 nodesnodenextif snullfor if twaitstatuslt stif snull sthread 最后 执行 unpark 之后 同步 队列 中 第一个 阻塞 的 线程 就被 唤醒 可以 尝试 更新 状态 了 关于 这块 具体 可以 参考 为什么 说 locksupport 是 java 并发 的 基石 推荐 阅读 浅谈 synchronized 与 原理 java 线程 的 那些 状态 们 如何 优雅 的 让 个 线程 打印 abcddd 的 领域 概念 们 如何 解决 大 分页 查询 问题 从 侵入 式 服务 治 理到 servicemesh 