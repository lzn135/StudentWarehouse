synchronized 七种 场景 应用 总结 本篇 博客 是 慕 课 网 java 高 并发 之 魂 synchronized 深度 解析 的 笔记 一 两个 线程 同时 访问 一个 对象 的 同步 方法 分析 首先是 同一个 对象 并且是 同步 方法 这 属于 对象 锁 中 的 普通 同步 方法 锁 效果 是 线程 顺序 执行 method 同步 方法 锁 getname 开始 执行 trythreadsleep catch getname 执行 完毕 stringargs 两个 线程 synchtest synchtest tstart tstart while tisalive tisalive finished 执行 结果 二 两个 线程 访问 的 两个 对象 的 同步 方法 分析 访问 不同 的 对象 如果 要 实现 同步 的话 锁 的 级别 应 该到 类 锁 但 题中 是 同步 方法 属于 对象 级别 的 所以 不同 对象 不受 干扰 线程 并行 运行 method 同步 方法 锁 getname 开始 执行 trythreadsleep catch getname 执行 完毕 stringargs 两个 线程 不同 对象 synchtest synchtest tstart tstart while tisalive tisalive finished 运行 结果 三 两个 线程 访问 的 是 synchronized 静态 方法 分析 在上 篇文章 中 提到 synchronized 修饰 的 静态 方法 锁 的 级 别是 类 锁 不管 是不是 同一个 对象 线程 都是 顺序 同步 执行 synchronized 关键字 生效 method 同步 静态 方法 锁 getname 开始 执行 trythreadsleep catch getname 执行 完毕 stringargs 两个 线程 不同 对象 synchtest synchtest tstart tstart while tisalive tisalive finished 执行 结果 四 同时 访问 同步 方法 和 非 同步 方法 分析 一个 线程 访问 同步 方法 一个 线程 访问 非 同步 方法 两者 是否 受影响 synchronized 影响 范围 是 它 修饰 的 方 法体 对 其它 方法 不受 影响 结论 就是 非 同步 方法 不受 影响 该 怎么 运行 还 怎么 运行 即使 修饰 的 是 静态 方法 也 不受 影响 因为 锁 类型 不同 如果是 线程 直接 执行 方法 线程 执行 方法 publicvoidrun if threadequals getname method elsemethod 同步 方法 getname 开始 执行 同步 方法 trythreadsleep catch getname 同步 方法 执行 完毕 非 同步 方法 getname 开始 执行 非 同步 方法 trythreadsleep catch getname 非 同步 方法 执行 完毕 stringargs 两个 线程 同一 对象 synchtest synchtest tstart tstart while tisalive tisalive finished 运行 结果 五 访问 同一个 对象 的 不同 的 普通 同步 方法 分析 有点 绕 没办法 面试题 经常 就是 很 绕 的 最 好把 面试官 也 给 绕 进去 算了 同一个 对象 的 两个 线程 其中 一个 线程 访问 类 的 同步 方法 另一个 线程 访问 同步 方法 两者 受影响 吗 普通 同步 方法 默认 是 this 对象 级别 的 锁 类型 相同 所以 同一个 对象 的 线程 访问 两个 方法 是 受影响 的 顺序 执行 不会 并行 的 如果是 线程 直接 执行 方法 线程 执行 方法 publicvoidrun if threadequals getname method elsemethod 同步 方法 getname 开始 执行 同步 方法 trythreadsleep catch getname 同步 方法 执行 完毕 同步 方法 getname 开始 执行 同步 方法 trythreadsleep catch getname 同步 方法 执行 完毕 stringargs 两个 线程 同一 对象 synchtest synchtest tstart tstart while tisalive tisalive finished 运行 结果 六 同时 访问 静态 synchronized 方法 和 非 静态 synchronized 方法 分析 这个 情况 比较复杂 根据 以上 结论 可以 得出 只要 两个 线程 的 锁 类型 相同 就是 同步 不相同 则 并行 不受 干扰 静态 同步 方法 锁 级 别是 类 锁 非 静态 同步 方法 级 别是 对象 锁 所以 并行 不受 干扰 的 如果是 线程 直接 执行 方法 线程 执行 方法 publicvoidrun if threadequals getname method elsemethod 静态 同步 方法 getname 开始 执行 静态 同步 方法 trythreadsleep catch getname 静态 同步 方法 执行 完毕 非 静态 同步 方法 getname 开始 执行 非 静态 同步 方法 trythreadsleep catch getname 非 静态 同步 方法 执行 完毕 stringargs 两个 线程 同一 对象 synchtest synchtest tstart tstart while tisalive tisalive finished 执行 结果 延伸 一下 两个 都是 静态 方法 呢 由于 都是 类 锁 不管 线程 是不是 一个 对象 的 都是 顺序 执行 同步 运作 下个 例子 就用 这个 来 验证 对象 锁 同步 代码 块 锁 普通 方法 锁 类 锁 static 方法 锁 class 锁 七 方法 抛 异常 后 是否 会 释放 锁 答案 是 会 自动 释放 锁 具体 原理 后续 展开讨论 如果是 线程 直接 执行 方法 线程 执行 方法 publicvoidrun if threadequals getname method elsemethod 静态 同步 方法 getname 开始 执行 静态 同步 方法 trythreadsleep catch 抛出 异常 getname 静态 同步 方法 执行 完毕 非 静态 同步 方法 getname 开始 执行 静态 同步 方法 trythreadsleep catch getname 静态 同步 方法 执行 完毕 stringargs 两个 线程 synchtest synchtest tstart tstart while tisalive tisalive finished 运行 结果 