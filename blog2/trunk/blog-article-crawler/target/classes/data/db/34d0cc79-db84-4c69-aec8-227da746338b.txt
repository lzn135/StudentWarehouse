beanfactory 与 factorybean beanfactory 是什么 spring 的 ioc 容器 是 一个 但是 这 只是 它被 冠以 ioc 之名 的 部分 原因 我们 不能 忽略 的 是 容器 spring 的 ioc 容器 是 一个 提供 ioc 支持 的 轻量级 容器 除了 基本 的 ioc 支持 它 作为 轻量级 容器 还 提供 了 ioc 之外 的 支持 如在 spring 的 ioc 容器 之上 spring 还 提供 了 相应 的 aop 框架 支持 企业级 服务 集成 等 服务 spring 的 ioc 容器 和 所 提供 的 服务 之间 存在 一定 的 交集 二者 的 关系 如图所示 spring 提供 了 两种 容器 类型 beanfactory 和 基础 类型 ioc 容器 提供 完整 的 ioc 服务 支持 如果 没有 特殊 指定 默认 采用 延迟 初始化 策略 lazyload 所以 相对来说 容器 启动 初期 速度 较快 所 需要 的 资源 有限 对于 资源 有限 并且 功能 要求 不是 很 严格 的 场景 beanfactory 是 比较 合适 的 ioc 容器 选择 在 beanfactory 的 基础上 构建 是 相对 比较 高级 的 容器 实现 除了 拥有 beanfactory 的 所有 功能 之外 还 提供 了 其他 高级 特性 比如 事件 发布 国际化 信息 支持 等 这些 会在 后面 详述 所 管理 的 对象 在 该 类型 容器 启动 之后 默认 全部 初始化 并 绑定 完成 所以 相对于 beanfactory 来说 要求 更多 的 系统资源 同时 因为 在 启动时 就 完成 所有 初始化 容器 启动 时间 较之 beanfactory 也 会长 一些 在那些 系统资源 充足 并且 要求 更多 功能 的 场景 中 类型 的 容器 是 比较 合适 的 选择 通过 图 我们 可 以对 beanfactory 和 之间 的 关系 有 一个 更 清晰 的 认识 beanfactory 顾名思义 就是 生产 bean 的 工厂 当然 严格来说 这个 生产过程 可能 不像 说起来 那么 简单 既然 spring 框架 提倡 使用 pojo 那么 把 每个 业务 对象 看作 一个 javabean 对象 或许 更 容易 理解 为什么 spring 的 ioc 基本 容器 会 起 这么 一个 名字 作为 spring 提供 的 基本 的 ioc 容器 beanfactory 可以 完成 作为 的 所有 职责 包括 业务 对象 的 注册 和 对象 间 依赖 关系 的 绑定 beanfactory 就像 一个 汽车 生产厂 你 从 其他 汽车零件 厂商 或者 自己 的 零件 生产部门 取得 汽车零件 送入 这个 汽车 生产厂 最后 只需 要从 生产线 的 终点 取得 成品 汽车 就可以 了 相 似地 将 应用 所需 的 所有 业务 对象 交给 beanfactory 之后 剩下 要做 的 就是 直接 从 beanfactory 取得 最终 组装 完成 并且 可用 的 对象 至于 这个 最终 业务 对象 如何 组装 你 不需要 关心 beanfactory 会 帮你 搞定 所以 对于 客户端 来说 与 beanfactory 打交道 其实 很简单 最基本 地 beanfactory 肯定会 公开 一个 取得 组装 完成 的 对象 的 方法 接口 就像 代码 清单 中 真正 的 beanfactory 的 定义 所 展示 的 那样 stringname stringname stringname stringname stringname stringname 上面 代码 中 的 方法 基本上 都是 查询 相关 的 方法 例如 取得 某个 对象 的 方法 getbean 查询 某个 对象 是否 存在于 容器 中 的 方法 containsbean 或者 取得 某个 bean 的 状态 或者 类型 的 方法 等 因为 通常情况下 对于 独立 的 应用程序 只 有主 入口 类 才会 跟 容器 的 api 直接 耦合 是 spring 容器 提供 的 一种 可以 扩展 容器 对象 实例 化 逻辑 的 接 口请 不要 将其 与 容器 名称 beanfactory 相 混淆 factorybean 其 主语 是 bean 定语 为 factory 也就是说 它本身 与其 他 注册 到 容器 的 对象 一样 只是 一个 bean 而已 只不过 这种 类型 的 bean 本身 就是 生产 对象 的 工厂 factory 当 某些 对象 的 实例 化 过程 过于 烦琐 通过 xml 配置 过于 复杂 使 我们 宁愿 使用 java 代码 来 完成 这个 实例 化 过程 的 时候 或者 某些 第三方 库 不能 直接 注册 到 spring 容器 的 时候 就可以 实 接口 给出 自己 的 对象 实例 化 逻辑 码 当然 不 使用 factorybean 而 像 通常 那样 实现 自定义 的 工厂 方法 类 也是 可以 的 不过 factorybean 可是 spring 提供 的 对付 这种 情况 的 制式 装备 哦 要 实现 并 使用 自己 的 factorybean 其实 很简单 只 定义 了 三个 方法 如以 下 代码 所示 方 法会 返回 该 factorybean 生产 的 对象 实例 我们 需要 实现 该 方法 以 给出 自己 的 对象 实例 化 逻辑 getobjecttype 方法 仅 返回 getobject 方法 所 返回 的 对象 的 类型 如果 预先 无法 确 定则 返回 nullissingleton 方法 返回 结果 用于 表明 工厂 方法 getobject 所 生产 的 对象 是否 要以 singleton 形式 存在于 容器 中 如果 以 singleton 形式 存在 则 返回 true 否则 返回 false 如果 我们 想 每次 得到 的 日期 都是 第二天 可以 实现 一个 如下 所示 的 plusdays returnfalse 很简单 的 实现 不是 嘛 要 使用 只需要 如下 这样 将其 注册 到 容器 即可 配置 上 看不出 与 平常 的 bean 定义 有 何 不同 不过 只有 当 我们 看到 的 定义 的 时候 才会 知道 factorybean 的 魔力 到底 在哪 的 定义 如下 相应 的 setter 方法 看到 了嘛 所 声明 的 依赖 dateofnextday 的 类型 为 datetime 而 不是 也就是说 factorybean 类型 的 bean 定义 通过 正常 的 id 引用 容器 返回 的 是 是 factorybean 所 生产 的 对象 类型 而非 factorybean 实现 本身 如果 一 定要 取得 factorybean 本身 的话 可以 通过 在 bean 定义 的 id 之前 加前缀 amp 来 达到 目的 下面 代码 展示 了 获取 factorybean 本身 与 获取 factorybean 生产 的 对象 之间 的 差别 nextdaydate asserttrue ampnextdaydate asserttrue asserttrue factorybean factorybean getobject asserttrue assertnotsame assertequals datetime nextdaydate getdayofyear datetime factoryvalue getdayofyear spring 容器 内部 许多地方 了 使用 factorybean 下面 是 一些 比较 常见 的 factorybean 实现 你 可以 参照 factorybean 的 javadoc 以 了解 更多 内容 