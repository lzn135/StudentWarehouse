系统 结构 不同 地址 数据 指令 的 访 存 次数 右 拉 回到 目录 写在 前面 的话 三 地址 双 操作数 指令 二 地址 双 操作数 指令 一 地址 双 操作数 指令 零 地址 双 操作数 指令 二 地址 r 型 指令 写在 前面 的话 开门见山 这篇 博客 主 要讲 下不 同 地址 数据 指令 的 访 存 次数 是 怎么 计算 的 其实是 计算机 系统 结构 课 的 第三次 homework 三 地址 双 操作数 指令 三 地址 双 操作数 指令 有 个 显 地址 其中有 两个 源 操作数 地址 一个 目标 地址 指令 执行 后 不会 破坏 任一 个 操作数 执行 一条 三 地址 的 加法 指令 需要 访问 次 主存 第一次 从 主存 中 取 指令 第二 三次 从 主存 中 取 操作数 第四次 将 结果 保 存到 主存 单元 中 课本 源码 分析 共 有条 三 地址 指令 每条 指令 需要 次 访 存 执行 此 程序 共 需要 访 存 次 二 地址 双 操作数 指令 二 地址 双 操作数 指令 有 两个 显 地址 第一个 操作数 地址 同时 兼 作 结果 存放 地址 执行 一条 二 地址 的 加法 指令 同样 需要 访问 次 主存 第一次 从 主存 地址 中 取 指令 第二 三次 从 主存 地址 中 取 操作数 第四次 将 加法 结果 存 放到 主存 单元 中 课本 源码 分析 共 有条 二 地址 指令 mov 指令 执行 一次次 访 存 读 指令 读 一次 操作数 写 一次 操作数 算术 运算 指令 次 访 存 执行 此 程序 共 访 存 次 一 地址 双 操作数 指令 一 地址 双 操作数 指令 只有 一个 显 地址 参加 运算 的 另一个 操作数 来自 累加器 寄存器 acc 执行 一条 一 地址 的 加法 指令 只需要 访问 两次 主存 第一次 从 主存 单元 中 取 指令 第二次 从 主存 单元 中 取 操作数 由于 第一 操作数 和 运算 结果 都 放在 累加器 寄存器 中 所以 读取 第一 操作数 和 存放 加法 的 结果 都不 需要 访问 主存 课本 源码 分析 共 需要 条 一 地址 指令 每条 指令 次 访 存 执行 此 程序 共 访 存 次 零 地址 双 操作数 指令 零 地址 双 操作数 指令 中 只有 操作码 字段 操作数 地址 都是 隐含 的 操作数 在 堆栈 的 栈 顶 位置 和 次 栈 顶 位置 它们 分 别从 堆栈 中 弹出 送到 运算器 中进 行 运算 运算 的 结果 再压 入 堆栈 执行 一条 零 地址 的 加法 指令 访问 主存 的 次数 取决于 堆栈 的 结构 课本 源码 分析 共 需要 条 执行 其中 条 一 地址 的 进出 栈 指令 条 零 地址 的 算术 运算 指令 进出 栈 指令 次 访 存 算术 逻辑 指令 次 访 存执 行 程序 共 访 存 次 二 地址 r 型 指令 课本 源码 分析 movera 次 mulrb 次 addrc 次 subrd 次 movere 次 addrf 次 divrr 次 movexr 次次 