mysql 解决 幻 读 mvcc 与 间隙 锁 当前 读 与 快 照读 当前 读 共享 读 锁 当前 读 读取 的 是 最新 版本 并且 对 读取 的 记录 加锁 阻塞 其他 事务 同时 改动 相同 记录 避免 出现 安全问题 例如 假设 要 update 一条 记录 但是 另一个 事务 已经 delete 这条 数据 并且 commit 了 如果 不 加锁 就会 产生 冲突 所以 update 的 时候 肯定 要是 当前 读 得到 最新 的 信息 并且 锁定 相应 的 记录 快 照读 简单 的 select 操作 不包括 readcommitted 隔离 级别 每次 select 都 生成 一个 快 照读 readrepeatable 隔离 级别 开启 事务 后 第一个 select 语句 才是 快 照读 的 地方 而 不是 一 开启 事务 就 快照 读在 rr 级 别下 快 照读 是 通过 mvvc 多 版本 控制 和 undolog 来 实现 的 当前 读 是 通过 加 recordlock 记录 锁 和 gaplock 间隙 锁 来 实现 的 如何 解决 幻 读 快 照读 的 幻 读 是 用 mvcc 解决 的 当前 的 读 的 幻 读 是 用 间隙 锁 解决 的 innodb 的 默认 事务 隔离 级 别是 rr 可 重 复读 它 的 实现 技术 是 mvcc 该 技术 不仅 可以 保证 innodb 的 可 重 复读 而且 可以 防止 幻 读 这也 就是 是 此前 以 rr 隔离 级别 实践 时 不仅 可以 防止 可 重 复读 也 防止 了 幻 读 但是 它 防止 的 是 快 照读 也 就是 读取 的 数据 虽然是 一致 的 但是 数据 是 历史数据 这个 帖子 里面 就有 一个 实例 mysql 的 innodb 的 幻 读 问题 一些 文章 写到 innodb 的 可 重 复读 避免了 幻 读 phantomread 这个 说法 并不 准确 那 innodb 指出 的 可以 避免 幻 读 是 怎么回事 呢 以下 翻译 自 mysql 官 网 文档 翻译 水平 一般 请 见谅 当 隔离 级 别是 可 重 复读 且 禁用 的 情况 下在 搜索 和 扫描 index 的 时候 使用 的 nextkeylocks 可以 避免 幻 读 也就是说 的 间隙 锁 innodb 提供 了 nextkeylocks 但 需要 应用程序 自己 去 加锁 举个 例子 该 查询 从 id 大于 的 第一条 记录 开始 扫描 索引 如果 该 表 包含 具有 id 在 和 值 的 行 如果在 扫描 范围内 的 索引 记 录上 设置 的 锁 没有 锁定在 间隙 中 插入 的 内容 在 这种 情况 下在 介于 和 之间 则 另一个 事务 可以 在 表 中 插入 一个 新 行 其 行号 id 为 如果您 要在 同一个 事务 中 执行 相同 的 select 您 将在 查询 返回 的 结果 集中 看到 一个 id 为 的 新 行 一个 幻影 这就 产 生了 幻 读 这与 事务 的 隔离 原 则是 相反 的 一个 事务 应该 能够 运行 以便 它 已经 读 的 数据 在 事务 过程中 不 改变 如果 我们 把 一套 行 视为 数据项 新 的 幽灵 子 记录 可能会 违反 这一 隔离 原则 为了 防止 幻影 innodb 使 用了 一种 名为 nextkeylocking 的 算法 它将 索引 行 锁定 和 间隙 锁定 结合 在一起 innodb 执 行行 级 锁 的 方式 是 当 它 搜索 或 扫描 一个 表 索引 时 它 会在 遇到 的 索引 记 录上 设置 共享 或 独占 锁 因 此行 级 锁 实际上 是 索引 记录 锁 此外 索引 记 录上 的 nextkeylock 也 会 影响 该 索引 记录 之前 的 间隙 也就是说 nextkeylock 是 一个 indexrecordlock 索引 记录 锁 加上 一个 在 索引 记录 之前 的 间隙 上 的 gaplock 间隙 锁 如果 一个 会话 在 索引 中 的 记录 r 上 具有 共享 锁 或 独占 锁 则 另一个 会话 不 能在 r 之前 的 间隙 中 插入 新 的 索引 记录 当 innodb 扫描 一个 索引 之时 它也 锁定 所有 记录 中 最后 一个 记录 之后 的 间隙 刚 在前 一个 例子 中 发生 innodb 设置 的 锁定 防止 任何 插入 到 id 可能 大过 的 表 所有 插入 id 为 的 数据 是 无法 执行 的 您可 以 使用 nextkeylock 在 应用程序 中 实现 唯一性 检查 如果 你 读 数据 时 加了 共享 锁 生成 表 级 共享 锁 允许 其它 线程 读取 数据 但 不能 修改 数据 和 没有 看到 你 要 复制 的 行 插入 那么 您 可以 安全地 插 入行 并且 明白 在 读取 期间 对 您 的 行 的 后续 行 设置 的 nextkey 锁 将 防止 任何人 同时 为 您 的 行 插入 副本 因此 nextkey 锁 允许 您 锁定 表 中 不存在 的 内容 假设 我们 有 一个 表 city 结构 如 下在 第一个 查询 窗 口中 开始 一个 事务 事务 a 事务 成都 问 事务 a 的 三个 select 分别 是什么 结果 第一个 南京 广州 杭州 第二个 南京 广州 杭州 第三个 南京 广州 杭州 成都 我们 可以 看出 如果 使用 普通 的 读 会 得到 一致性 的 结果 如果 使 用了 加锁 的 读 就会 读到 最新 的 提交 读 的 结果 如果 需要 实时 显示 数据 还是 需要 通过 手动 加锁 来 实现 这个 时候 会 使用 nextkey 技术 来 实现 本身 可 重 复读 和 提交 读 是 矛盾 的 在 同一个 事务 里 如果 保证 了 可 重 复读 就会 看不到 其他 事务 的 提交 违背 了 提交 读 如果 保证 了 提交 读 就会 导致 前后 两次 读到 的 结果 不一致 违背 了 可 重 复读 innodb 提供 了 这样 的 机制 在 默认 的 可 重 复读 的 隔离 级别 里 可以 使用 加锁 读 去 查询 最新 的 数据 insharemode 我们 再 开启 一个 事务 执行 济南 commit 会 怎样 结果是 阻塞 因为 加了 间隙 锁 我们 再 开启 一个 事务 执行 济南 济南 whereidcommit 会 怎样 修改 成功 没问题 间隙 锁 没 加到 这 如果 我 写 济南 whereid 肯定会 阻塞 因为 间隙 锁 的 原因 结论 mysqlinnodb 的 可 重 复读 并不 保证 避免 幻 读 需要 应用 使用 加锁 读来 保证 而 这个 加锁 度 使 用到 的 机制 就是 nextkeylocks 在 mysql 中 提供 了 两种 事务 隔离 技术 第 一个是 mvcc 第二个 是 nextkey 技术 这个 在 使用 不同 的 语句 的 时候 可以 动态 选择 不加 lockinsharemode 之类 的 快 照读 就 使用 mvcc 否则 当前 读 使用 nextkeymvcc 的 优势 是 不 加锁 并 发性 高 缺点 是不是 实时 数据 nextkey 的 优势 是 获取 实时 数据 但是 需要 加锁 另外 重 要在 rr 级 别下 mvcc 完全 解决 了 重 复读 但 并不能 真正 的 完全避免 幻 读 只是在 部分 场景 下 利用 历史数据 规 避了 幻 读 对于 快 照读 mysql 使用 mvcc 利用 历史数据 部分 避免了 幻 读在 某些 场景 看上去 规 避了 幻 读 要 完全避免 需要 手动 加锁 将 快 照读 调整 为 当前 读 mysql 不会 自动 加锁 然后 mysql 使用 nextkey 完全 避免了 幻 读 比如 rr 下 锁 另一个 线程 的 insert 即被 阻 塞在 rc 下 另一个 线程 仍然 可以 大摇大摆 的 插入 如 本 线程 再次 查询 比如 count 则会 不一致 建议 去看 官方 文档 参考 文章 innodb 当前 读 与 快 照读 mysql 的 innodb 的 幻 读 问题 相关 的 官方 文档 mysql 的 锁 机制 记录 锁 间隙 锁 临 键 锁 mysql 当前 读 快 照读 mvcc 