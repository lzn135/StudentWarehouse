经典 golang 语法 50 问 前言 golang 这门 语言 想必 大家 都不 陌生 现在 也 比较 火 学习 的人 也 比较 多 作为 一款 性能 还算 不错 的 语言 现在 很多 大厂 的 新项目 都 选择 了 golang 这期 针对 大家 的 疑惑 总 结了 大厂 系列 golang 语法 问供 大家 面试 和 学 习用 下面 看一下 提纲 使用 值 为 nil 的 slicemap 会 发生 啥 允许 对 值 为 nil 的 slice 添加 元素 但对 值 为 nil 的 map 添加 元素 则会 造成 运行时 panicmap 错误 示例 funcmain mapstringint map 的 正确 声明 分 配了 实际 的 内存 slice 正确 示例 funcmain varsintsappend s 访问 map 中 的 key 需要 注意 啥 当 访问 map 中 不存在 的 key 时 go 则会 返回 元素 对应 数据类型 的 零 值 比如 nilfalse 和 取值 操作 总有 值 返回 故 不能通过 取出来 的 值 来 判断 key 是不是 在 map 中 检查 key 是否 存在 可以用 map 直接 访问 检查 返回 的 第二个 参数 即可 错误 的 key 检测 方式 funcmain keytwoisnoentry 键 two 存 不存在 都会 返回 的 空 字符串 正确 示例 funcmain keytwoisnoentry string 类型 的 值 可以 修改 吗 不能 尝试 使用 索引 遍历 字符串 来 更新 字符串 中 的 个别 字符 是 不允许 的 string 类型 的 值 是 只读 的 二进制 byteslice 如果 真要 修改 字符串 中 的 字符 将 string 转为 byte 修改后 再 转为 string 即可 修改 字符串 的 错误 示例 funcmain x 修改 示例 funcmain xtextxbytesbyte x xbytest 注意 此时 的 t 是 rune 类型 xstring xbytes fmtprintln x textswitch 中 如何 强制执行 下一个 case 代码 块 switch 语 句中 的 case 代码 块 会 默认 带上 break 但可以 使用 fallthrough 来 强制执行 下一个 case 代码 块 funcmain isspacefunc charbyte 空格符 会 直接 break 返回 false 和 其他 语言 不一样 fallthrough 返回 isspace t truefmtprintln isspace false 你 是 如何 关闭 http 的 响应 体 的 直 接在 处理 http 响应 错误 的 代码 块 中直 接 关闭 非 nil 的 响应 体 手动 调用 defer 来 关闭 响应 体 正确 示例 funcmain resperrhttpget httpwwwbaiducom 关闭 respbody 的 正确 姿势 checkerror err respbody checkerror err fmtprintln string body 你 是否 主动 关闭 过 http 连接 为啥 要 这样 做 有 关闭 不关 闭会 程序 可能会 消耗 完 socket 描述符 有如 下种 关闭 方式 直接 设置 请求 变量 的 close 字段 值 为 true 每次 请求 结束 后 就会 主动 关闭 连接 设置 header 请求 头部 选项 connectionclose 然后 服务器 返回 的 响应 头部 也 会有 这个 选项 此时 http 标准 库 会 主动 断开 连接 主动 关闭 连接 funcmain checkerror err connectionclose 等效 的 关闭 方式 req checkerror err respbody checkerror err fmtprintln string body 你 可以 创建 一个 自定义 配置 的 httptransport 客户端 用来 取消 http 全局 的 复用 连接 funcmain checkerror err fmtprintln respstatuscode respbody checkerror err fmtprintln len string body 解析 json 数据 时 默认 将 数值 当做 哪种 类型 在 数据 时 go 默认 会将 数值 当做 float 处理 funcmain vardatabyte status dataampresult err 解析 出来 的 是 float 类型 如何 从 panic 中 恢复 在 一个 defer 延迟 执行 的 函数 中 调用 recover 它 便能 捕捉 中断 panic 错误 的 recover 调用 示例 funcmain recover 什么 都不会 捕捉 panic notgood 发生 panic 主程序 退出 recover 不会 被执行 println ok 正确 的 recover 调用 示例 funcmain deferfunc fmtprintln panic notgood 简短 声明 的 变量 需要 注意 啥 简短 声明 的 变量 只 能在 函数 内部 使用 struct 的 变量 字段 不能 使 用来 赋值 不 能用 简短 声明 方式 来 单独 为 一个 变量 重复 声明 左侧 至少有 一个 新 变量 才 允许 多 变量 的 重复 声明 range 迭代 map 是 有序 的 吗 无序 的 go 的 运行时 是 有意 打乱 迭代 顺序 的 所以 你 得到 的 迭代 结果 可能 不一致 但也 并不 总会 打乱 得到 连续 相同 的 个 迭代 结果 也是 可能 的 recover 的 执行 时机 无 recover 必 须在 defer 函数 中 运行 recover 捕获 的 是 祖父 级 调 用时 的 异常 直接 调 用时 无效 funcmain recover panic 直接 defer 调用 也是 无效 funcmain deferrecover panic defer 调 用时 多层 嵌套 依然 无效 funcmain deferfunc func recover panic 必 须在 defer 函数 中 直接 调用 才 有效 funcmain deferfunc recover panic 闭 包 错误 引用 同一个 变量 问题 怎么 处理 在 每 轮 迭代 中 生成 一个 局部变量 i 如果 没有 ii 这行 将会 打印 同一个 变量 funcmain println i 或者是 通过 函数 参数 传入 ifuncmain iint println i i 在 循环 内部 执行 defer 语句 会 发生 啥 defer 在 函数 退出 时 才能 执 行在 for 执行 defer 会 导致 资源 延迟 释放 funcmain foriiltifunc ferrosopen pathtofile err deferfclose func 是 一个 局部 函数 在 局部 函数 里面 执行 defer 将不 会有 问题 说 出 一个 避免 goroutine 泄露 的 措施 可以 通过 context 包 来 避免 内存 泄漏 funcmain chfunc ltchanintchmake chanint gofunc returncasechlti returnch ctx v ifvcancel break 下面 的 for 循环 停止 取 数据 时 就用 cancel 函数 让 另一 个协 程 停止 写 数据 如果 下面 for 已 停止 读取 数据 上面 for 循环 还在 写入 就会 造成 内存 泄漏 如何 跳出 forselect 循环 通常在 for 循环 中 使用 break 可以 跳出 循环 但是 注 意在 go 语 言中 forselect 配 合时 break 并不能 跳出 循环 chexitchanbool closechannelv chvalv exitfmtprintln 如 何在 切 片中 查找 go 中 使用 sortsearchxxx 方法 在 排序 好 的 切 片中 查找 指定 的 方法 但是 其 返回 是 对应 的 查找 元素 不存在 时 待 插入 的 位置 下标 元素 插入 在 返回 下标 前 可以 通过 封装 如下 函数 达到 目的 funcisexist sstringtstring intbool st bexistiindexlen s 如何 初始化 带 嵌套 结构 的 结构 体 go 的 哲学 是 组合 优于 继承 使用 struct 嵌套 即可 完成 组合 内嵌 的 结构 体 属性 就像 外层 结构 的 属性 即可 可以 直接 调用 注意 初始化 外层 结构 体 时 必须 指定 内嵌 结构 体 名称 的 结构 体 初始化 如下 看到 s 方式 报错 s 方式 式 正确 尝试 嵌套 结构 的 初始化 表达式 切片 和 数组 的 区别 数组 是 具有 固定 长度 且 拥有 零个 或者 多个 相同 数据类型 元素 的 序列 数组 的 长度 是 数组 类型 的 一部分 所以 int 和 int 是 两种 不同 的 数组 类型 数组 需要 指定 大小 不 指定 也 会 根据 初始化 的 自动 推算出 大小 不可 改变 数组 是 值 传递 数组 是 内置 类型 是 一组 同 类型 数据 的 集合 它是 值 类型 通 过从 开始 的 下标 索引 访问 元素 值 在 初始化 后 长度 是 固定 的 无法 修改 其 长度 当 作为 方法 的 参数 传 入时 将 复制 一份 数组 而 不是 引用 同一 指针 数组 的 长度 也是 其 类型 的 一部分 通过 内置 函数 len array 获 取其 长度 数组 定义 切片 表示 一个 拥有 相同 类型 元素 的 可变 长度 的 序列 切片 是 一种 轻量级 的 数据结构 它有 三个 属性 指针 长度 和 容量 切片 不需要 指定 大小 切片 是 地址 传递 切片 可以 通过 数组 来 初始化 也 可以 通过 内置 函数 make 初始化 初始 化时 lencap 在 追加 元素 时 如果 容量 cap 不足 时 将 按 len 的 倍 扩容 切片 定义 typelen new 和 make 的 区别 new 的 作 用是 初始化 一个 指向 类型 的 指针 t new 函数 是 内建函数 函数 定义 funcnew type type 使用 new 函 数来 分配 空间 传 递给 new 函数 的 是 一个 类型 不是 一个 值 返回值 是 指向 这个 新 分配 的 零 值 的 指针 make 的 作 用是 为 slicemap 或 chan 初始化 并 返回 引用 t make 函数 是 内建函数 函数 定义 funcmake type 第一个 参数 是 一个 类型 第二个 参数 是 长度 返回值 是 一个 类型 make targs 函数 的 目的 与 new t 不同 它 仅仅 用于 创建 slicemap 和 channel 并且 返回 类型 是 t 不是 t 的 一个 初始化 的 不是 零 值 的 实例 printf sprintf fprintf 函数 的 区别 用法 是什么 都是 把 格式 好 的 字符串 输出 只是 输出 的 目标 不一样 printf 是 把 格式 字符串 输 出到 标准 输出 一般 是 屏幕 可以 重定向 printf 是 和 标准 输出 文件 stdout 关联 的 fprintf 则没 有 这个 限制 sprintf 是 把 格式 字符串 输 出到 指定 字符串 中 所以 参数 比 printf 多 一个 char 那就是 目标 字符串 地址 fprintf 是 把 格式 字符串 输 出到 指定 文件 设备 中 所以 参数 比 printf 多 一个 文件 指针 file 主要 用于 文件 操作 fprintf 是 格式化 输 出到 一个 stream 通常是 到 文件 说说 go 语 言中 的 for 循环 for 循环 支持 continue 和 break 来 控制 循环 但是 它 提供 了 一个 更 高级 的 break 可以 选择 中断 哪一个 循环 for 循环 不支持 以 逗 号为 间隔 的 多个 赋值 语句 必须 使用 平行 赋值 的 方式 来 初始化 多个 变量 array 类型 的 值 作为 函数 参数 在 cc 中 数组名 是 指针 将 数组 作为 参数 传 进 函数 时 相当于 传 递了 数组 内存地址 的 引 用在 函数 内部 会 改变 该 数组 的 值 在 go 中 数组 是 值 作为 参数 传 进 函数 时 传递 的 是 数组 的 原始 值 拷贝 此时 在 函数 内部 是 无法 更新 该 数组 的 数组 使用 值 拷贝 传 参 funcmain xintfunc arrint arrfmtprintln arr x fmtprintln x 并不是 你 以为 的 想 改变 数组 直接 传递 指向 这个 数组 的 指针 类型 传 址 会 修改 原 数据 funcmain xintfunc arrint arr fmtprintln arr amp ampx fmtprintln x 直接 使用 slice 即使 函数 内部 得到 的 是 slice 的 值 拷贝 但 依旧会 更新 slice 的 原始数据 底层 array 错误 示例 funcmain v 正确 示例 funcmain 使用 丢弃 索引 fmtprintln v 说 go 语 言中 的 for 循 说说 go 语 言中 的 switch 语句 单个 case 中 可以 出现 多个 结果 选项 只有 在 case 中 明确 添加 fallthrough 关键字 才会 继续 执行 紧跟 的 下一个 case 说说 go 语言 中有 没有 隐藏 的 this 指针 方法 施加 的 对象 显 式 传递 没有 被 隐藏 起来 golang 的 面向对象 表达 更 直观 对于 面向 过程 只是 换了 一种 语法 形式 来 表达方法 施加 的 对象 不需要 非得 是 指针 也 不用 非得 叫 thisgo 语 言中 的 引用 类型 包含 哪些 数组 切片 字典 map 通道 channel 接口 interfacego 语言 中 指针 运算 有 哪些 可以 通过 amp 取 指针 的 地址 可以 通过 取 指针 指向 的 数据 说说 go 语言 的 main 函数 main 函数 不 能带 参数 main 函数 不能 定义 返回值 main 函数 所在 的 包 必须 为 main 包 main 函数 中 可以 使用 flag 包 来 获取 和 解析 命令行 参数 go 语言 触发 异常 的 场景 有 哪些 空 指针 解析 下标 越界 除数 为 调用 panic 函数 说说 go 语言 的 beego 框架 beego 是 一个 golang 实现 的 轻量级 http 框架 beego 可以 通过 注释 路由 正则 路由 等 多种 方式 完成 url 路由 注入 可以 使用 beenew 工具 生成 空 工程 然后 使用 beerun 命令 自动 热 编译 说说 go 语言 的 goconvey 框架 goconvey 是 一个 支持 golang 的 单元测试 框架 goconvey 能够 自动 监控 文件 修改 并 启动 测试 并可以 将 测试 结果 实时 输 出到 web 界面 goconvey 提供 了 丰富 的 断言 简化 测 试用 例 的 编写 gostub 的 作用 是什么 gostub 可 以对 全局变量 打桩 gostub 可 以对 函数 打桩 gostub 不可 以对 类 的 成员 方法 打桩 gostub 可以 打 动态 桩 比 如对 一个 函数 打桩 后 多次 调用 该 函数 会有 不同 的 行为 go 语言 编程 的 好处 是什么 编译 和 运行 都 很快 在 语言 层级 支持 并行 操作 有 垃圾 处理器 内置 字符串 和 maps 函数 是 go 语言 的 最基本 编程 单位 说说 go 语言 的 select 机制 select 机制 用来 处理 异步 io 问题 select 机制 最大 的 一条 限制 就是 每个 case 语句 里 必须 是 一个 io 操作 golang 在 语言 级别 支持 select 关键字 解释一下 go 语 言中 的 静态 类型 声明 静态 类型 声明 是 告诉 编译器 不需要 太多 的 关注 这个 变量 的 细节 静态 变量 的 声明 只是 针对于 编译 的 时候 在 连接 程序 的 时候 编译器 还 要对 这个 变量 进行 实际 的 声明 go 的 接口 是什么 在 go 语 言中 interface 也 就是 接口 被 用来 指定 一个 对象 接口 具有 下面 的 要素 一系列 的 方法 具体 应用 中 并 用来 表示 某个 数据类型 在 go 中 使用 interface 来 实现 多态 go 语言 里面 的 类型 断言 是 怎么回事 类型 断言 是 用来 从一 个 接口 里面 读取 数值 给 一个 具体 的 类型 变量 类型 转换 是 指 转换 两个 不相同 的 数据类型 go 语言 中 局部变量 和 全局变量 的 缺省值 是什么 全局变量 的 缺省值 是 与 这个 类型 相关 的 零 值 go 语言 编程 的 好处 是什么 编译 和 运行 都 很快 在 语言 层级 支持 并行 操作 有 垃圾 处理器 内置 字符串 和 maps 函数 是 go 语言 的 最基本 编程 单位 解释一下 go 语 言中 的 静态 类型 声明 静态 类型 声明 是 告诉 编译器 不需要 太多 的 关注 这个 变量 的 细节 静态 变量 的 声明 只是 针对于 编译 的 时候 在 连接 程序 的 时候 编译器 还 要对 这个 变量 进行 实际 的 声明 模块化 编程 是 怎么回事 模块化 编程 是 指 把 一个 大 的 程序 分解成 几个 小 的 程序 这么 做的 目的 是为了 减少 程序 的 复杂度 易于 维护 并且 达到 最高 的 效率 码字 不易 请 不吝 点 赞 随手 关注 更多 精彩 自动 送达 golang 的 方法 有 什么 特别之处 函数 的 定义 声明 没有 接收者 方法 的 声明 和 函数 类似 他们 的 区 别是 方法 在 定义 的 时候 会在 func 和 方 法名 之间 增加 一个 参数 这个 参数 就是 接收者 这样 我们 定义 的 这个 方法 就和 接收者 绑 定在 了 一起 称之为 这个 接收者 的 方法 go 语言 里 有 两种 类型 的 接收者 值 接收者 和 指针 接收者 使用 值 类型 接收者 定义 的 方法 在 调用 的 时候 使用 的 其实是 值 接收者 的 一个 副本 所 以对 该 值 的 任何 操作 不会 影响 原来 的 类型 变量 相当于 形式参数 如果 我们 使用 一个 指针 作为 接收者 那么 就会 其 作 用了 因为 指针 接收者 传递 的 是 一个 指向 原值 指针 的 副本 指针 的 副本 指向 的 还是 原来 类型 的 值 所以 修 改时 同时 也 会 影响 原来 类型 变量 的 值 golang 可变 参数 函数 方法 的 参数 可 以是 任意 多个 这种 我们 称之为 可以 变 参数 比如 我们 常用 的 fmtprintln 这类 函数 可以 接收 一个 可变 的 参数 可以 变 参数 可 以是 任意 多个 我们 自己 也 可以 定义 可以 变 参数 可变 参数 的 定义 在 类型 前 加上 省略号 即可 funcmain print funcprint ainterface v fmtprintln 例子 中 我们 自己 定义 了 一个 接受 可变 参数 的 函数 效果 和 fmtprintln 一样 可变 参数 本质上 是 一个 数组 所以 我们 向 使用 数组 一样 使用 它 比如 例子 中 的 forrange 循环 golangslice 的 底层 实现 切片 是 基于 数组 实现 的 它 的 底层 是 数组 它自己 本身 非常 小 可以 理解为 对 底层 数组 的 抽象 因为 基于 数组 实现 所以 它 的 底层 的 内存 是 连续 分配 的 效率 非常 高 还 可以 通过 索引 获得 数据 可以 迭代 以及 垃圾 回收 优化 切片 本身 并不是 动态 数组 或者 数组 指针 它 内部 实现 的 数据结构 通过 指针 引用 底层 数组 设定 相关 属性 将 数据 读写 操作 限 定在 指定 的 区域内 切片 本身 是 一个 只读 对象 其 工作 机制 类似 数组 指针 的 一种 封装 切片 对象 非常 小 是因为 它是 只有 个 字段 的 数据结构 指向 底层 数组 的 指针 切片 的 长度 切片 的 容量 这个 字段 就是 go 语言 操作 底层 数组 的 元 数据 golangslice 的 扩容 机制 有 什么 注意 点 go 中 切片 扩容 的 策略 是 这样 的 首先 判断 如果 新 申请 容量 大于 倍 的 旧 容量 最终 容量 就是 新 申请 的 容量 否则 判断 如果 旧 切片 的 长度 小于 则 最终 容量 就是 旧 容量 的 两倍 否则 判断 如果 旧 切片 长度 大于 等于 则 最终 容量 从 旧 容量 开始 循环 增加 原来 的 直到 最终 容量 大于 等于 新 申请 的 容量 如果 最终 容量 计算 值 溢出 则 最终 容量 就是 新 申请 容量 情况 一 原 数组 还有 容量 可以 扩容 实际 容量 没有 填充 完 这种 情况下 扩容 以后 的 数组 还是 指向 原来 的 数组 对 一个 切片 的 操作 可能 影响 多个 指针 指向 相同 地址 的 slice 情况 二 原来 数组 的 容量 已经 达 到了 最大值 再想 扩容 go 默认 会 先开 一片 片 内存 区域 把 原来 的 值 拷贝 过来 然后再 执行 append 操作 这种 情况 丝毫 不影响 原 数组 要 复制 一个 slice 最好 使用 copy 函数 golangmap 底层 实现 golang 中 map 的 底层 实 现是 一个 散 列表 因此 实现 map 的 过程 实际上 就是 实现 散 表 的 过程 在 这个 散 列表 中 主要 出现 的 结构 体 有 两个 一个 叫 hmap 一个 叫 bmap 通常 叫 其 bucket hmap 如下 所示 图中 有 很多 字段 但是 便于 理解 map 的 架构 你 只需要 关心 的 只有 一个 就是 标 红 的 字段 buckets 数组 golang 的 map 中 用于 存储 的 结构 是 bucket 数组 而 bucket 即 bmap 的 结构 是 怎样 的 呢 bucket 相比 于 hmapbucket 的 结构 显得 简单 一些 标 橙 的 字段 依然是 核心 我们 使用 的 map 中 的 key 和 value 就 存储 在这里 高位 哈希 值 数组 记录 的 是 当前 bucket 中 key 相关 的 索引 稍 后会 详细 叙述 还有 一个 字段 是 一个 指向 扩容 后 的 bucket 的 指针 使得 bucket 会 形成 一个 链表 结构 整体 的 结构 应该是 这样 的 golang 把 求得 的 哈希 值 按照 用途 一分为二 高位 和 低位 低位 用于 寻找 当前 key 属于 hmap 中 的 哪个 bucket 而 高位 用于 寻找 bucket 中 的 哪个 key 需要 特别 指出 的 一点 是 map 中 的 keyvalue 值 都是 存到 同一个 数组 中 的 这样 做的 好处 是 在 key 和 value 的 长度 不同 的 时候 可以 消除 padding 带来 的 空间 浪费 map 的 扩容 当 go 的 map 长度 增长到 大于 加载 因子 所需 的 map 长度 时 go 语言 就 会将 产生 一个 新 的 bucket 数组 然后 把 旧 的 bucket 数组 移到 一个 属性 字段 oldbucket 中 注意 并不是 立刻 把 旧 的 数组 中 的 元素 转义 到 新 的 bucket 当中 而是 只 有当 访 问到 具体 的 某个 bucket 的 时候 会把 bucket 中 的 数据 转移到 新 的 bucket 中 json 标准 库 对 nilslice 和 空 slice 的 处理 是 一致 的 吗 首先 json 标准 库 对 nilslice 和 空 slice 的 处理 是 不一致 通常 错误 的 用法 会报 数组 越界 的 错误 因为 只是 声 明了 slice 却没有 给 实例 化 的 对象 此时 slice 的 值 是 nil 这种 情况 可以 用于 需要 返回 slice 的 函数 当 函数 出现异常 的 时候 保证 函数 依然 会有 nil 的 返回值 emptyslice 是 指 slice 不为 nil 但是 slice 没有 值 slice 的 底层 的 空间 是 空 的 此时 的 定义 如下 slicemake intsliceint 当 我们 查询 或者 处理 一个 空 的 列表 的 时候 这 非常 有用 它会 告诉 我们 返回 的 是 一个 列表 但是 列表 内 没有 任何 值 总之 nilslice 和 emptyslice 是 不同 的 东西 需要 我们 加以 区分 的 golang 的 内存 模型 为什么 小 对象 多了 会 造成 gc 压力 通常 小 对象 过 多会 导致 gc 三 色法 消耗 过多 的 gpu 优化 思路 是 减少 对象 分配 datarace 问题 怎么 解决 能不 能不 加锁 解决 这个 问题 同步 访问共享 数据 是 处理 数据 竞争 的 一种 有效 的 方法 golang 在 之后 引 入了 竞争 检测 机制 可以 使用 gorunrace 或者 gobuildrace 来 进行 静态 检测 其 在内部 的 实 现是 开启 多 个协 程 执行 同一个 命令 并且 记 录下 每个 变量 的 状态 竞争 检测器 基于 cc 的 threadsanitizer 运行时 库 该 库 在 google 内部 代码 基地 和 chromium 找到 许多 错误 这个 技术 在年 九月 集成 到 go 中 从 那时 开始 它 已经在 标准 库 中 检 测到 个 竞争 条件 现在 它 已经是 我们 持续 构建 过程 的 一部 分当 竞争 条件 出 现时 它会 继续 捕捉到 这些 错误 竞争 检测器 已经 完全 集成 到 go 工具 链 中 仅仅 添加 race 标志 到 命令行 就使 用了 检测器 gotestracemypkg 测试 包 编译 和 运行 程序 构建 程序 安装 程序 要想 解决 数据 竞争 的 问题 可以 使用 互斥 锁 syncmutex 解决 数据 竞争 datarace 也 可以 使用 管道 解决 使用 管道 的 效率 要比 互斥 锁 高 在 range 迭代 slice 时 你 怎么 修改 值 的 在 range 迭代 中 得到 的 值 其实是 元素 的 一份 值 拷贝 更新 拷贝 并不会 更改 原来 的 元素 即是 拷贝 的 地址 并不是 原有 元素 的 地址 funcmain 中原 有 元素 是 不 会被 修改 的 fmtprintln datadata data 如果 要 修改 原有 元素 的 值 应该 使用 索引 直接 访问 funcmain datadata data 如果 你 的 集合 保存 的 是 指向 值 的 指针 需 稍作 修改 依旧 需要 使用 索引 访问 元素 不过 可以 使用 range 出来 的 元素 直接 更新 原有 值 funcmain 直接 使用 指针 更新 fmtprintln datadatadata 和 nilinterface 的 区别 虽然 interface 看起来 像 指针 类型 但它 不是 interface 类型 的 变量 只有 在 类型 和 值 均为 nil 时 才 为 nil 如果 你 的 interface 变量 的 值 是 跟随 其他 变量 变化 的 与 nil 比较 相等 时 小心 如果 你 的 函数 返回值 类型 是 interface 更要 小心 这个 坑 funcmain datadatanil ininnil ininnil 值 为 nil 但 in 值 不为 nil 正确 示例 funcmain doitfunc argint 明确 指明 返回 goodresultres elsefmtprintln badresultres 可以 用于 什么 常用语 gorotine 的 完美 退出 golang 的 select 就是 监听 io 操作 当 io 操作 发生 时 触发 相应 的 动作 每个 case 语句 里 必须 是 一个 io 操作 确切的说 应该是 一个 面向 channel 的 io 操作 结尾 本文 总 结了 常见 的 go 语法 问题 且 在 工作 和 面试 中都 容易 出错 的 可 以供 大家 学习 和面 试用 golang 的 开源 社区 在 不断 的 壮大 是 一门 值得 学习 的 语言 我 公众 号 有 golang 学习 的 全面 资料 可以 领取 祝 大家 学习 愉快 微 信 搜索 晨 梦 思 雨 关注 这个 不一样 的 程序员 作者 介绍 csdntop 原创 文章 资深 golangc 开发 现就职 于 知名 互联网 大厂 本号 分享 后台 开发 技术 包括 算法 与 数据结构 笔试 面试 网络 编程 数据库 理论 操作系统 it 杂文 