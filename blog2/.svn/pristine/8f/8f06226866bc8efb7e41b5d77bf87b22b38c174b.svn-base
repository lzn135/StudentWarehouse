阿里 开源 的 线程 间 上下文 传递 解决方案 戳 蓝字 topcoder 关注 我们 哦 是 一个 线程 间 传递 threadlocal 异步 执 行时 上下文 传递 的 解决方案 整个 库 的 核心 是 构 建在 类 继承 并 加强 类 之上 同时 包含 线程 池 修饰 以及 javaagent 支持 代码 小于 k 行 短小精悍 在 往下 看 之前 最好 大致 看下 文档 效果 会 更好 jdk 的 类 可以 完成 父 线程 到 子 线程 的 值 传递 但 对于 使用 线程 池 等 会 池 化 复用 线程 的 组件 的 情况 线程 由 线程 池 创 建好 并且 线程 是 池 化 起来 反复 使用 的 这时 父子 线程 关系 的 threadlocal 值 传递 已经 没有意义 应用 需要 的 实际上 是 把 任务 提 交给 线程 池 时 的 threadlocal 值 传递 到 任务 执 行时 原理 是 使用 包 装了 类 在 初始 化时 变量 在 run 方法 调用 runnablerun 前 进行 replay 设置 到 当前 线程 threadlocal 在 run 方法 调用 runnablerun 后 进行 restore 上下文 还原 也 就是 replay 的 反向 操作 注意 步骤 和 步骤 不是 在 同一个 线程 中 执行 的 既然 ttl 的 是 继承 并 加强 类 的 那么 首先 需要 分析 下 是什么 东东 源码 如下 新建 线程 时 如果 当前 非 空 则会 获取 当前 传 递给 新 线程 tparentvalue 变量 的 setgetremove 操作 都是 在 上 threadt 创建 thisfirstvalue thread 类 中有 两个 threadlocal 相关 的 threadlocalmap 属性 如下 变量 使用 变量 使用 新建 线程 时 将 当前 线程 的 传 递给 新 线程 这里 的 传递 是 对 变量 的 数据 做 浅 拷贝 引用 复制 这样 新 线程 可以 使用 同一个 变量 查看 上一个 线程 的 数据 下面 分析 下 使用 的 一个 线程 池 parentset executorsubmit getname parentget 输出 结果 上面 代码 在 submit 任务 时会 伴随着 线程 池 工作 线程 的 创建 会 继承 当前 线程 的 所以 会有 上述 输出 结果 如果 将 代码 改成 下面 的 样子 会有 什么 不同 呢 线程 池 executorsubmit gt 先 进行 工作 线程 创建 parentset executorsubmit getname parentget 输出 结果 poolthreadnull 因为 创建 线程 时 当前 线程 并没有 所以 线程 池中 线程 打印 结果 为 null 这种 场景 下 如何 才能 获 取到 parent 变量 的 数据 呢 这时 就 该 ttl 出场 了 将 上述 代码 改成 ttl 方式 如下 线程 池 executorsubmit gt 先 进行 工作 线程 创建 使用 parentset 将 runnable 通过 ttlrunnable 包 装下 executorsubmit ttlrunnableget getname parentget 输出 结果 下面 以 ttlrunnableget 为 起点 分析 ttl 的 设计 实现 ttlrunnableget 源码 如下 ttlrunnableget 流程 对应 的 初始 化时 capture 操作 保存 快照 ttlcallable 和 ttlrunnable 流程 类似 returnget if 幂 等 时 直接 返回 否则 执 行会 产生 问题 直接 抛 异常 if idempotent return ttlrunnable capture 从 holder 获取 所有 threadlocal 存到 captured 这里 相当于 对 当前 线程 holder 做一个 快照 保 存到 ttlrunnable 实例 属性 中 在 执行 ttlrunnable 时 进行 回放 for keyset capturedput returncaptured 在 新建 ttlrunnable 过程 中会 保 存下 到 captured 记 录到 ttlrunnable 实例 中 的 capturedref 字段 类型 是 因为 没有 weakset 的 原因 parentvalue 从 上面 代码 我们 知道 初始化 ttlrunnable 时 已经 将 保存 下 来了 那么 什么时候 应用到 当前 线程 threadlocal 中 呢 这是 就需要 看下 ttlrunnablerun 方法 publicvoidrun captured 不应 该为 空 为 true 时 设置 capturedref 为 null 防止 当前 runnable 重复 执行 if capturednull captured 进行 回放 应用到 当前 线程 中 captured tryrunnablerun finallyrestore backup 注意 ttl 中 的 replay 操作 是以 captured 为 当前 的 处理 逻辑 是 在 ttlrunablerun 时会 以 ttlrunnableget 时间 点 获取 的 captured 类似 ttl 快照 为准 holder 中 不在 captured 的 先 移除 在 的 会被 替换 关于 replay 中 的 讨论 可以 参考 回放 captured 和 执行 完 runnablerun 之后 再 restore 恢复 到 原来 的 状态 说 完了 ttl 中 的 capturereplay 和 restore 流程 再看 下 官方 提供 的 这个 时序 图 是不是 感觉 清晰 很多 除了 通过 ttlrunableget 修饰 用户 自定义 的 task 之外 还 可以 修饰 线程 池 和 使用 javaagent 修饰 jdk 线程 池 实现 类 的 方式 实现 ttl 功能 修饰 线程 池 省去 每次 runnable 和 callable 传入 线程 池 时 的 修饰 这个 逻辑 可以 在 线程 池中 完成 其实 就是在 提交 task 时 调用 ttlrunableget 修饰 下 通过 工具 类 完成 有 下面 的 方法 getttlexecutor 修饰 接口 修饰 接口 修饰 接口 使用 javaagent 来 修饰 jdk 线程 池 实现 类 这种 方式 实现 线程 池 的 传递 是 透明 的 代码 中 没有 修饰 runnable 或是 线程 池 的 代码 即可以 做到 应用 代码 无 侵入 关于 无 侵入 的 更多 说明 参见 文档 javaagent 方式 对 应用 代码 无 侵入 使用 javaagent 实例 如下 启动 参数 中 需 加上 executorsubmit gt parentset executorsubmit getname parentget ttl 代码 实现 来看 确实 短小精悍 值得 花 几个 小时 看下 源码 通过 看 源码 我 发现了 可以 通过 newthreadlocal 对象 时 直接 重写 其 initialvalue 方法 可以 在 threadlocalget 为 空 时 初始化 一个 值 使用 示例 如下 localget initlocalset helloworld localget localget init 推荐 阅读 线程 池 如何 传递 线程 上下文 信息 java 并发 工具 那些 事儿 一起 聊 聊个 线程 依次 打印 的 故事 欢迎 小伙伴 关注 topcoder 阅读 更多 精彩 好文 