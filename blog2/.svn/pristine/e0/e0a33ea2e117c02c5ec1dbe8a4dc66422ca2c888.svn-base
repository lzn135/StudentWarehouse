java 多线程 访问 synchronized 同步 方法 的 八种 使用 场景 简介 本文 将 介绍 种 同步 方法 的 访问 场景 我们 来看 看着 八种 情况下 多线程 访问 同步 方法 是否 还是 线程 安全 的 这些 场景 是 多线程 编程 中 经常 遇到 的 而且 也是 面试时 高频 被 问到 的 问题 所以 不管是 理论 还是 实践 这些 都是 多线程 场景 必 须要 掌握 的 场景 八种 使用 场景 接下来 我们 来 通过 代码 实现 分别 判断 以下 场景 是不是 线程 安全 的 以及 原因 是什么 两个 线程 同时 访问 同一个 对象 的 同步 方法 两个 线程 同时 访问 两个 对象 的 同步 方法 两个 线程 同时 访问 一个 或 两个 对象 的 静态 同步 方法 两个 线程 分别 同时 访问 一个 或 两个 对象 的 同步 方法 和 非 同步 方法 两个 线程 访问 同一个 对象 中 的 同步 方法 同步 方法 又 调用 一个 非 同步 方法 两个 线程 同时 访问 同一个 对象 的 不同 的 同步 方法 两个 线程 分别 同时 访问 静态 synchronized 和 非 静态 synchronized 方法 同步 方法 抛出 异常 后 jvm 会 自动 释放 锁 的 情况 场景 一 两个 线程 同时 访问 同一个 对象 的 同步 方法 分析 这种 情况 是 经典 的 对象 锁 中 的 方法 锁 两个 线程 争夺 同一个 对象 锁 所以会 相互 等待 是 线程 安全 的 两个 线程 同时 访问 同一个 对象 的 同步 方法 是 线程 安全 的 我们 在前 文中 已经 讲 过了 代码 和 详细 讲解 在 java 中 synchronized 实现 对象 锁 的 两种 方式 及 原理 解析 中 的 第二 部分 方法 锁 中 在此 就 不再 重述 了 场景 二 两个 线程 同时 访问 两个 对象 的 同步 方法 这种 场景 就是 对象 锁 失效 的 场景 原因 出在 访问 的 是 两个 对象 的 同步 方法 那么 这两个 线程 分别 持有 的 两个 线程 的 锁 所以是 互相 不会 受限 的 加锁 的 目的 是为了 让 多个 线程 竞争 同一 把 锁 而 这种 情况 多个 线程 之间 不再 竞争 同一 把 锁 而是 分别 持有 一把 锁 所以 我们 的 结论是 两个 线程 同时 访问 两个 对象 的 同步 方法 是 线程 不安全 的 代码 验证 创建 两个 不同 的 对象 method 线程 名 getname 运行 开始 trythreadsleep catch 线程 getname 运行 结束 stringargs instance instance threadstart threadstart while threadisalive threadisalive 测试 结束 运行 结果 两个 线程 是 并行 执行 的 所以 线程 不安全 线程 名 thread 运行 开始 线程 名 thread 运行 开始 线程 thread 运行 结束 线程 thread 运行 结束 测试 结束 代码 分析 问题 在此 两个 线程 threadthread 访问 两个 对象 的 同步 方法 method 两个 线程 都有 各自 的 锁 不能 形成 两个 线程 竞争 一把 锁 的 局势 所以 这时 synchronized 修饰 的 方法 method 和 不用 synchronized 修饰 的 效果 一样 不信 去 把 synchronized 关键字 去掉 运行 结果 一样 所以 此时 的 method 只是 个 普通 方法 如何 解决 这个 问题 若 要使 锁 生效 只 需将 method 方法 用 static 修饰 这样 就 形 成了 类 锁 多个 实例 共同 竞争 一把 类 锁 就可 以使 两个 线程 串行 执 行了 这也 就是 下一个 场景 要讲 的 内容 场景 三 两个 线程 同时 访问 一个 或 两个 对象 的 静态 同步 方法 这个 场景 解决 的 是 场景 二中 出现 的 线程 不安全 问题 即用 类 锁 实现 两个 线程 同时 访问 一个 或 两个 对象 的 静态 同步 方法 是 线程 安全 的 关 于此 方法 的 代码 实现 和 详细 讲解 参考 文章 java 中 synchronized 实现 类 锁 的 两种 方式 及 原理 解析 中 的 第二 部分 静态 方法 锁 的 方式 实现 类 锁 在此 不再 重述 场景 四 两个 线程 分别 同时 访问 一个 或 两个 对象 的 同步 方法 和 非 同步 方法 这个 场景 是 两个 线程 其中 一个 访问 同步 方法 另一个 访问 非 同步 方法 此时 程序 会不会 串行 执行 呢 也就是说 是不是 线程 安全 的 呢 我们 可以 确 定是 线程 不安全 的 如果 方法 不加 synchronized 都是 安全 的 那就 不需要 同步 方法 了 验证 下 我们 的 结论 两个 线程 分别 同时 访问 一个 或 两个 对象 的 同步 方法 和 非 同步 方法 是 线程 不安全 的 两个 线程 访问 同步 方法 和 非 同步 方法 if getname equals thread 线程 执行 同步 方法 method method if getname equals thread 线程 执行 非 同步 方法 method method 同步 方法 线程 名 getname 同步 方法 运行 开始 trythreadsleep catch 线程 getname 同步 方法 运行 结束 普通 方法 线程 名 getname 普通 方法 运行 开始 trythreadsleep catch 线程 getname 普通 方法 运行 结束 stringargs instance instance threadstart threadstart while threadisalive threadisalive 测试 结束 运行 结果 两个 线程 是 并行 执行 的 所以是 线程 不安 去 的 线程 名 thread 同步 方法 运行 开始 线程 名 thread 普通 方法 运行 开始 线程 thread 同步 方法 运行 结束 线程 thread 普通 方法 运行 结束 测试 结束 结果 分析 问题在于 此 method 没有 被 synchronized 修饰 所以 不会 受到 锁 的 影响 即便是 在 同一个 对象 中 当然在 多个 实例 中 更不 会被 锁 影响 了 结论 非 同步 方法 不受 其它 由 synchronized 修饰 的 同步 方法 影响 你 可能 想到 一个 类似 场景 多个 线程 访问 同一个 对象 中 的 同步 方法 同步 方法 又 调用 一个 非 同步 方法 这个 场景 会是 线程 安全 的 吗 场景 五 两个 线程 访问 同一个 对象 中 的 同步 方法 同步 方法 又 调用 一个 非 同步 方法 我们 来 实验 下 这个 场景 用 两个 线程 调用 同步 方法 在 同步 方法 中 调用 普通 方法 再用 一个 线程 直接 调用 普通 方法 看看 是否 是 线程 安全 的 if getname equals thread 直接 调用 普通 方法 method else 先 调用 同步 方法 在 同步 方法 内 调用 普通 方法 method 同步 方法 线程 名 getname 同步 方法 运行 开始 trythreadsleep catch 线程 getname 同步 方法 运行 结束 开始 调用 普通 方法 method 普通 方法 线程 名 getname 普通 方法 运行 开始 trythreadsleep catch 线程 getname 普通 方法 运行 结束 stringargs 此 线程 直接 调用 普通 方法 instance 这两个 线程 直接 调用 同步 方法 instance instance threadstart threadstart threadstart while threadisalive threadisalive threadisalive 测试 结束 运行 结果 线程 名 thread 普通 方法 运行 开始 线程 名 thread 同步 方法 运行 开始 线程 thread 同步 方法 运行 结束 开始 调用 普通 方法 线程 名 thread 普通 方法 运行 开始 线程 thread 普通 方法 运行 结束 线程 thread 普通 方法 运行 结束 线程 名 thread 同步 方法 运行 开始 线程 thread 同步 方法 运行 结束 开始 调用 普通 方法 线程 名 thread 普通 方法 运行 开始 线程 thread 普通 方法 运行 结束 测试 结束 结果 分析 我们 可以 看出 普通 方法 被 两个 线程 并行 执行 不是 线程 安全 的 这是 为什么 呢 因为 如果 非 同步 方法 有 任何 其他 线程 直接 调用 而 不是 仅在 调用 同步 方法 时 才 调用 非 同步 方法 此时 会 出现 多个 线程 并行 执行 非 同步 方法 的 情况 线程 就不 安全 了 对于 同步 方法 中 调用 非 同步 方法 时 要想 保证 线程 安全 就必须 保证 非 同步 方法 的 入口 仅 出现在 同步 方法 中 但 这种 控制 方式 不够 优雅 若 被 不明 情况 的人 直接 调用 非 同步 方法 就会 导致 原有 的 线程 同步 不再 安全 所以 不 推荐 大家 在 项 目中 这样 使用 但 我们 要 理解 这种 情况 并且 我们 要用 语义 明确 的 让 人 一看 就 知道 这是 同步 方法 的 方式 来 处理 线程 安全 的 问题 所以 最 简单 的 方式 是 在 非 同步 方法 上 也 加上 synchronized 关键字 使其 变成 一个 同步 方法 这样 就 变 成了 场景 五 两个 线程 同时 访问 同一个 对象 的 不同 的 同步 方法 这种 场景 下 大家 就很 清楚 的 看到 同一个 对象 中 的 两个 同步 方法 不管 哪个 线程 调用 都是 线程 安全 的 了 所以 结论是 两个 线程 访问 同一个 对象 中 的 同步 方法 同步 方法 又 调用 一个 非 同步 方法 仅在 没有 其他 线程 直接 调用 非 同步 方法 的 情况下 是 线程 安全 的 若有 其他 线程 直接 调用 非 同步 方法 则是 线程 不安全 的 场景 六 两个 线程 同时 访问 同一个 对象 的 不同 的 同步 方法 这个 场景 也是 在 探讨 对象 锁 的 作用 范围 对象 锁 的 作用 范围 是 对象 中 的 所有 同步 方法 所以 当 访问 同一个 对象 中 的 多个 同步 方法 时 结论是 两个 线程 同时 访问 同一个 对象 的 不同 的 同步 方法 时 是 线程 安全 的 if getname equals thread 线程 执行 同步 方法 method method if getname equals thread 线程 执行 同步 方法 method method 线程 名 getname 同步 方法 运行 开始 trythreadsleep catch 线程 getname 同步 方法 运行 结束 线程 名 getname 同步 方法 运行 开始 trythreadsleep catch 线程 getname 同步 方法 运行 结束 运行 结果 串行 stringargs instance instance threadstart threadstart while threadisalive threadisalive 测试 结束 运行 结果是 线程 安全 的 线程 名 thread 同步 方法 运行 开始 线程 thread 同步 方法 运行 结束 线程 名 thread 同步 方法 运行 开始 线程 thread 同步 方法 运行 结束 测试 结束 结果 分析 两个 方法 method 和 method 的 synchronized 修饰符 虽 没有 指定 锁 对象 但 默认 锁 对象 为 this 对象 为 锁 对象 所以 对于 同一个 实例 instance 两个 线程 拿到 的 锁 是 同一 把 锁 此时 同步 方 法会 串行 执行 这 也是 synchronized 关键字 的 可 重入 性 的 一种 体现 场景 七 两个 线程 分别 同时 访问 静态 synchronized 和 非 静态 synchronized 方法 这种 场景 的 本质 也是 在 探讨 两个 线程 获取 的 是不是 同一 把 锁 的 问题 静态 synchronized 方法 属于 类 锁 锁 对 象是 class 对象 非 静态 synchronized 方法 属于 对象 锁 中 的 方法 锁 锁 对 象是 this 对象 两个 线程 拿到 的 是 不同 的 锁 自然 不会 相互影响 结论 两个 线程 分别 同时 访问 静态 synchronized 和 非 静态 synchronized 方法 线程 不安全 代码 实现 if getname equals thread 线程 执行 静态 同步 方法 method method if getname equals thread 线程 执行 非 静态 同步 方法 method method 重点 用 修饰 的 方法 属于 类 锁 锁 对象 为 class 对象 线程 名 getname 静态 同步 方法 运行 开始 trythreadsleep catch 线程 getname 静态 同步 方法 运行 结束 重点 synchronized 修饰 的 方法 属于 方法 锁 锁 对象 为 this 对象 线程 名 getname 非 静态 同步 方法 运行 开始 trythreadsleep catch 线程 getname 非 静态 同步 方法 运行 结束 运行 结果 并行 stringargs 问题 原因 线程 的 锁 是 类 锁 class 对象 线程 的 锁 是 方法 锁 this 对象 两个 线程 的 锁 不一样 自然 不会 互相 影响 所以会 并行 执行 instance instance threadstart threadstart while threadisalive threadisalive 测试 结束 运行 结果 线程 名 thread 静态 同步 方法 运行 开始 线程 名 thread 非 静态 同步 方法 运行 开始 线程 thread 非 静态 同步 方法 运行 结束 线程 thread 静态 同步 方法 运行 结束 测试 结束 场景 八 同步 方法 抛出 异常 后 jvm 会 自动 释放 锁 的 情况 本 场景 探讨 的 是 synchronized 释放 锁 的 场景 只 有当 同步 方法 执行 完 或 执 行时 抛出 异常 这两种 情况 才会 释放 锁 所以在 一个 线程 的 同步 方法 中 出现异常 的 时候 会 释放 锁 另一个 线程 得到 锁 继续 执行 而 不会 出现 一个 线程 抛出 异常 后 另一个 线程 一直 等待 获取 锁 的 情况 这是 因为 jvm 在 同步 方法 抛出 异常 的 时候 会 自动 释放 锁 对象 代码 实现 if getname equals thread 线程 执行 抛 异常 方法 method method if getname equals thread 线程 执行 正常 方法 method method 线程 名 getname 运行 开始 trythreadsleep catch 同步 方法 中 当 抛出 异常 时 jvm 会 自动 释放 锁 不需要 手动 释放 其他 线程 即可 获 取到 该 锁 线程 名 getname 抛出 异常 释放 锁 线程 名 getname 运行 开始 trythreadsleep catch 线程 getname 运行 结束 stringargs instance instance threadstart threadstart while threadisalive threadisalive 测试 结束 运行 结果 线程 名 thread 运行 开始 线程 名 thread 抛出 异常 释放 锁 线程 名 thread 运行 开始 conditionjava conditionjava threadjava 线程 thread 运行 结束 测试 结束 结果 分析 可以 看出 线程 还是 串行 执行 的 说明 是 线程 安全 的 而且 出现异常 后 不会 造成 死锁 现象 jvm 会 自动 释放 出现异常 线程 的 锁 对象 其他 线程 获取 锁 继续 执行 总结 本文 总 结了 并用 代码 实现 和 验证 了 synchronized 各种 使用 场景 以及 各种 场景 发生 的 原因 和 结论 我们 分析 的 理论基础 都是 synchronized 关键字 的 锁 对象 究竟是 谁 多个 线程 之间 竞争 的 是否 是 同一 把 锁 根据 这个 条件 来 判断 线程 是否 是 安全 的 所以有 了 这些 场景 的 分析 锻炼 后 我们 在 以后 使用 多线程 编程 时 也 可以 通过 分析 锁 对象 的 方式 判断 出 线程 是否 是 安全 的 从而 避免 此类 问题 的 出现 本文 涵 盖了 synchronized 关键字 的 最 重要 的 各种 实用 场景 也是 面试官 常 常会 问到 的 高频 问题是 一篇 值得 大家 仔细阅读 和亲 自动 手 实践 的 文章 喜欢 本文 请 点 赞 和 收藏 