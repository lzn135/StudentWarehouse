太 顶了 爆 肝 3.5w 字 长文 详解 java 集合 建议 收藏 前言 数据结构 作为 每一个 开发者 不可 回避 的 问题 而 java 对于 不同 的 数据结构 提供 了 非常 成熟 的 实现 这一个 又一个 实现 既是 面试 中 的 难点 也是 工作中 必不可少 的 工具 在此 笔者 经历 漫长 的 剖析 将其 抽丝剥茧 的 呈现 出来 在此 仅 作 抛砖引玉 望 得 诸君 高见 若 君 能有 所获 则 在下 甚是 不亦乐乎 若有 疑惑 亦 愿 与 诸君 共 求 之 本文 一共 w 字 张 图 预计 阅读 h 可以 收藏 这篇 文章 用 的 时候 防止 找不到 这 可能是 你 能 看到 的 最 详细 的 一篇 文章 了 整 理了 年 java 面试题 集合 框架 java 整个 集合 框架 如上图 所示 这儿 不包括 mapmap 的 结构 将 放在 集合 后边 进行 讲述 可见 所有 集合 实现 类 的 最 顶层 接口 为 iterable 和 collection 接口 再 向下 collection 分 为了 三种 不同 的 形式 分 别是 listqueue 和 set 接口 然后 就是 对应 的 不同 的 实现 方式 顶层 接口 iterable 支持 lambda 函数 接口 方法 action for ttthis actionaccept t iterator iterable 接 口中 只有 iterator 一个 接口 方法 iterator 也是 一个 接口 其主要 有 如下 两个 方法 hasnext 和 next 方法 booleanisempty booleancontains objecto objecttoarray booleanadd ee booleanremove objecto collectionltgtc collectionltgtc filter while eachhasnext if filtertest eachnext eachremove collectionltgtc voidclear inthashcode this spliterator false spliterator true 可见 collection 的 主要 接口 方法 有 listlist 表示 一串 有序 的 集合 和 collection 接口 含义 不同 的 是 list 突出 有序 的 含义 list 接口 ta booleanaddall booleanaddall operator while lihasnext liset operatorapply linext defaultvoidsort arrayssort a comparator c for objectea inext iset e e booleanequals objecto eget intindex eset voidadd intindexof objecto intlastindexof objecto 可见 list 其实 比 collection 多了 添加 方法 add 和 addall 查找 方法 getindexofset 等 方法 并且 支持 index 下标 操作 collection 与 list 的 区别 a 从 上边 可以 看出 collection 和 list 最大 的 区别 就是 collection 是 无序 的 不支持 索引 操作 而 list 是 有序 的 collection 没有 顺序 的 概念 blist 中 iterator 为 listiteratorc 由 a 推导 list 可以 进行 排序 所以 list 接口 支持 使用 sort 方法 d 二者 的 spliterator 操作 方式 不一样 为什么 子类 接 口里 重复 申明 父 类 接口 呢 官方 解释 在 子 接 口中 重复 声明 父 接口 是为了 方便 看 文档 比 如在 javadoc 文档 里 在 list 接 口里 也 能 看到 collecion 声明 的 相关 接口 list 实现 是 list 接口 最 常用 的 一个 实现 类 支持 list 接口 的 一些 列 操作 arraylist 继承 关系 arraylist 组成 真正 存放 元素 的 数组 一 定要 记住 arraylist 中 的 该 elementdata 是 真正 存放 元素 的 容器 可见 arraylist 是 基于 数组 实现 的 arraylist 构造 函数 if initialcapacity publicarraylist 是 arraylist 真正 存放 数据 的 数组 arraylist 支持 默认 大小 构造 和 空 构造 当空 构造 的 时候 存放 数据 的 是 一个 空 数组 arraylist 中 添加 元素 ee size 注意 arraylist 中有 一个 modcount 的 属性 表示 该 实例 修改 的 次数 所有 集合 中都 有 modcount 这样 一个 记录 修改 次数 的 属性 每次 增 改 添加 都会 增加 一次 该 arraylist 修改 次数 而 上边 的 add ee 方法 是 将 新元素 添加到 list 尾部 arraylist 扩容 if defaultcapacity 是 returnmathmax 可见 当 初始化 的 list 是 一个 空 arraylist 的 时候 会 直接 扩容 到 defaultcapacity 该 值 大小 是 一个 默认值 而 当 添 加进 arraylist 中 的 元素 超 过了 数组 能 存放 的 最大值 就会 进行 扩容 注意到 这一 行 代码 oldcapacitygtgt 采用 右移 运算 就是 原来 的 一般 所以是 扩容 倍 比如 的 二进制 是 右移 后 变成 就是 privatevoidgrow intmincapacity oldcapacitygtgt if mincapacity 数组 copyjava 是 无法 自己 分配 空间 的 是 底层 c 和 c 的 实 现以 c 为 例 我们 知道 c 中 数组 是 一个 指向 首部 的 指针 比如 我们 c 语言 对 数组 进行 分配 内存 java 就是 通过 arraycopy 这个 native 方法 实现 的 数组 的 复制 p int malloc lensizeof int 这样 的 好处 何在 呢 java 里 内存 是 由 jvm 管理 的 而 数组 是 分配 的 连续 内存 而 arraylist 不一 定是 连续 内存 当然 jvm 会 帮 我们 做 这样 的 事 jvm 会有 内部 的 优化 会在 后续 的 例子 中 结合 问题 来 说明 whyelementdata 用 transient 修饰 transient 的 作 用是 该 属性 不 参与 序列化 arraylist 继承 了 标示 序列化 的 serializable 接口 对 arraylist 序列化 的 过程中 进行了 读写 安全 控制 是 如何 实现 序列化 安全 的 呢 swriteint size intiiltsizei swriteobject elementdatai if ignoredif sizegt belikeclone elementdatasize checkarray size intiiltsizei aisreadobject 在 序列化 方法 writeobject 方法 中 可以 看到 先用 默认 写 方法 然后 将 size 写出 最后 遍历 写出 elementdata 因为 该 变量 是 transient 修饰 的 所有 进行 手动 写出 这样 它也 会被 序列 化了 那是 不是 多此一举 呢 当然 不是 其中有 一个 关键 的 modcount 该 变量 是 记录 list 修改 的 次数 的当 写入 完 之后 如果 发现 修改 次数 和 开始 序列化 前 不一致 就会 抛出 异常 序列化 失败 这样 就 保证 了 序列化 过程中 是 未经 修改 的 数据 保证 了 序列化 安全 java 集合 中 都是 这样 实现 linkedlist 众所周知 linkedlist 是 一种 链表 结构 那么 java 里 linkedlist 是 如何 实现 的 呢 linkedlist 继承 关系 可见 linkedlist 既是 list 接口 的 实现 也是 queue 的 实现 deque 故 其 和 arraylist 相比 linkedlist 支持 的 功能 更多 其 可 视作 队列 来 使用 当然 下 文中 不强调 其 队列 的 实现 linkedlist 的 结构 由 一 个头 节点 和 一个 尾 节点 组成 分别 指向 链表 的 头部 和 尾部 linkedlist 中 node 源码 如下 由 当前 值 item 和 指向 上一个 节点 prev 和 指向 下个 节点 next 的 指针 组成 并且 只 含有 一个 构造 方法 按照 previtemnext 这样 的 参数 顺序 构造 那 linkedlist 里 节点 node 是什么 结构 呢 linkedlist 由 一 个头 节点 一个 尾 节点 和 一个 默 认为 的 size 构成 可见 其 是 双向 链表 数据结构 中 链表 的 头 插 法 linkfirst 和 尾 插 法 头 插 法 ee nullef firstnewnodeif fnull 尾 插 法 voidlinklast ee lenull lastnewnodeif lnull 查询方法 按照 下标 获取 某一个 节点 get 方法 获取 第 index 个 节点 publiceget intindex index returnnode index itemnode index 方法 是 怎么 实现 的 呢 判断 index 是 更 靠近 头部 还是 尾部 靠近 哪 段 从 哪 段 遍历 获 取值 nodeltegtnode intindex index 判断 index 更 靠近 头部 还是 尾部 if indexlt sizegtgt intiiltindexi xxprevreturnx 查询 索引 修改 方法 先 找到 对应 节 点将 新 的 值 替 换掉 老 的 值 publiceset index nodeltegtxnode index 这个 也是 为什么 arraylist 随机 访问 比 linkedlist 快 的 原因 linkedlist 要 遍历 找到 该 位置 才能 进行 修改 而 arraylist 是 内部 数组 操作 会 更快 linkedlist 修改 方法 新增 一个 节点 可以 看到 是 采用 尾 插 法 将 新 节点 放入 尾部 ee linklast e 和 arraylist 一样 vector 也是 list 接口 的 一个 实现 类 其中 list 接口 主要 实现 类 有 其中 后 两者 用 的 特别 少 vector 组成 和 arraylist 基本 一样 存放 元素 的 数组 有效 元素 数量 小于 等于 数组 长度 protect 容量 增加量 和 扩容 相关 线程 安全性 vector 是 线程 安全 的 synchronized 修饰 的 操作方法 vector 扩容 privatevoidgrow intmincapacity 扩容 大小 if mincapacity 看 源码 可知 扩容 当 构造 没有 时 一次 扩容 数组 变成 原来 两倍 否则 每次 增加 方法 经典 示例 移除 某一 元素 intindex modcountif index index nummovedgt 复制 数组 假设 数组 移 除了 中间 某 元素 后边 有效值 前 移位 systemarraycopy 引用 nullgc 会 处理 这儿 主要有 一个 两行 代码 需要 注意 笔者 在 代码 中有 注释 数组 移除 某一 元素 并且 移动 后 一定 要将 原来 末尾 设为 null 且 有效 长度 减 总体上 vector 实 现是 比较简单 粗暴 的 也 很少 用到 随便 看看 即可 stackstack 也是 list 接口 的 实现 类 之 一和 vector 一样 因为 性能 原因 更 主 要在 开发 过程中 很少 用到 栈 这种 数据结构 不过 栈 在 计算机 底层 是 一种 非常重要 的 数据结构 下边 将 探讨 下 java 中 stackstack 的 继承 关系 stack 继承 于 vector 其 也是 list 接口 的 实现 类 之前 提 到过 vector 是 线程 安全 的 因为 其 方法 都是 synchronized 修饰 的 故 此处 stack 从父 类 vector 继承 而来 的 操作 也是 线程 安全 的 stack 的 使用 正如 stack 是 栈 的 实现 故 其主要 操 作为 push 入 栈 和 pop 出 栈 而 栈 最大 的 特点 就是 stringspush aaa stringspush bbb stringspush ccc stringspop 上边 代码 可以 看到 最后 push 入 栈 的 字符串 ccc 也 最 先出 栈 stack 源码 stack 源码 入 栈 使用 的 是 vector 的 addelement 方法 publicepush eitem addelement item returnitem 出 栈 找到 数组 最后 一个 元素 移除 并 返回 eobjintlensize objpeek removeelementat len intlensize if len returnelementat len returnsize objecto intilastindexof o if igt returnsize 从 stack 的 源码 中 可见 其 用 的 push 方法 用 的 是 vector 的 addelementee 方法 该 方法 是 将 元素 放在 集合 的 尾部 而其 pop 方法 使用 的 是 vector 的 removeelementat indexx 方法 移除 并 获取 集合 的 尾部 元素 可见 stack 的 操作 就是 基于 线性表 的 尾部 进行 操作 的 queue 正如 数据结构 中 描述 queue 是 一种 先进先出 的 数据结构 也 就是 firstinfirstout 可以 将 queue 看作 一个 只可以 从 某一 段 放 元素 进去 的 一个 容器 取 元素 只 能从 另一端 取 整个 机制 如 下图 所示 不过 需要 注意 的 是 队列 并没有 规 定是 从 哪 一端 插入 从 哪一 段 取出 什么 是 dequedeque 英文 全 称是 也 就是 俗称 的 双 端 队列 就是说 对于 这个 队列 容器 既可以 从 头部 插入 也 可以 从 尾部 插入 既可以 从 头部 获取 也 可以 从 尾部 获 取其 机制 如 下图 所示 java 中 的 queue 接口 此处 需要 注意 java 中 的 队列 明确 有 从 尾部 插入 头部 取出 所以 java 中 queue 的 实现 都是 从 头部 取出 集合 中 插入 元素 booleanadd ee 队列 中 插入 元素 booleanoffer ee 移除 元素 当 集 合为 空 抛出 异常 eremove 移除 队列 头部 元素 并 返回 如果 为 空 返回 nullepoll 查询 集合 第一个 元素 如果 为 空 抛出 异常 eelement 查询 队列 中 第一个 元素 如果 为 空 返回 nullepeek javaqueue 常常 使用 的 方法 如 表格 所示 对于 表格 中 接口 和 表格 中 没有 的 接口 方法 区 别为 队列 的 操作 不会 因为 队 列为 空 抛出 异常 而 集合 的 操作 是 队 列为 空 抛出 异常 deque 接口 的 操作方法 voidaddfirst ee voidaddlast ee ee ee eremovefirst eremovelast epollfirst epolllast egetfirst egetlast epeekfirst epeeklast objecto objecto ee booleanoffer ee eremove epoll eelement epeek 省略 一堆 stack 接口 方法 和 collection 接口 方法 和 queue 中 的 方法 一样 方 法名 多了 first 或者 lastfirst 结尾 的 方法 即从 头部 进行 操作 last 即从 尾部 进行 操作 queuedeque 的 实现 类 java 中 关于 queue 的 实现 主 要用 的 是 双 端 队列 毕竟 操作 更加 方便 自由 queue 的 实现 有 在 javautil 中 主要有 arraydeque 和 linkedlist 两个 实现 类 两者 一个是 基于 数组 的 实现 一个是 基于 链表 的 实 现在 之前 linkedlist 文章 中 也 提 到过 其 是 一个 双向 链表 在此 基础 之上 实现 了 deque 接口 是 java 中 唯一 一个 queue 接口 的 直接 实现 如其 名字 所示 优先 队列 其 内部 支持 按照 一定 的 规则 对 内部 元素 进行 排序 priorityqueue 继承 关系 先 看下 priorityqueue 的 继承 实现 关系 可知 其 是 queue 的 实现 类 主要 使用 方式 是 队列 的 基本 操作 而 之前 讲 到过 queue 的 基本原理 其 核心 是 原理 java 中 的 priorityqueue 的 实现 也是 符合 队列 的 方式 不过 又 略有不同 却 别 就在于 priorityqueue 的 priority 上 其 是 一个 支持 优先级 的 队 列当 使 用了 其 priority 的 特性 的 时候 则 并非 的 使用 案 列 queueadd queueadd queueadd queueadd queueadd queueadd queueadd queueadd queueadd queueadd while queuesize gt systemerrprint pollgt 上述 代码 做的 事 为 往 队列 中 放入 个 int 值 然后 使用 queue 的 poll 方法 依次 取出 最后 结果 为 每次 取出来 都是 队列 中 最小 的 值 说 明了 priorityqueue 内部 确 实是 有 一定 顺序 规则 的 案例 必须 实现 comparable 方法 想 string 数值 本身 即可 比较 inta inta testo stringargs queueadd newtest queueadd newtest queueadd newtest queueadd newtest queueadd newtest queueadd newtest queueadd newtest queueadd newtest queueadd newtest queueadd newtest while queuesize gt systemerrprint pollgt 上述 代码 重 写了 compareto 方法 都 返回 即 不做 优先级 排序 发现 我们 返回 的 顺序 为 和 放入 的 顺序 还是 不同 所以 这儿 需要 注 意在 实现 comparable 接口 的 时候 一 定要 按照 一定 的 规则 进行 优先级 排序 关于 为什么 取出来 的 顺序 和 放入 的 顺序 不一致 后边 将从 源码 来 分析 priorityqueue 组成 默认 容量 大小 数组 大小 存放 元素 的 数组 队列 中 存 放了 多少 元素 privateintsize 自定义 的 比较 规则 有 该 规则 时 优先 使用 否则 使用 元素 实现 的 comparable 接口 方法 队列 修改 次数 每次 存取 都 算 一次 修改 可以 看到 priorityqueue 的 组成 很简单 主要 记住 一个 存放 元素 的 数组 和 一个 comparator 比较 器 即可 priorityqueue 操作方法 offer 方法 ee if enull igtqueuelength grow i sizeiisize 当 queue 为 空 的 时候 if i ie returntrue 首先 可以 看到 当 queue 中 为 空 的 时候 第一次 放入 的 元素 直接 放在 了 数组 的 第一位 那么 上边 案例 二中 第一个 放入 的 就在 数组 的 第一位 而 当 queue 中 不为 空 时 又 使用 siftup ie 方法 传入 的 参数 是 队列 中 已有 元素 数量 和 即 将要 放入 的 新元素 现在 就来 看下 究竟 siftup ie 做了 什么事 intkex if comparatornull kx kx 还记得 上边 提到 priorityqueue 的 组成 是 一个 存放 元素 的 数组 和 一个 comparator 比较 器 这儿 是 指 当 没有 comparator 是 使用 元素 类 实现 compareto 方法 进行 比较 其 含义 为 优先 使用 自定义 的 比较 规则 comparator 否则 使用 元素 所在 类 实现 的 comparable 接口 方法 intkex xwhile kgt 为什么 思考 数组 位置 是 和 的 父 节点 intparent k gtgtgt 父 节点 当 传入 的 新 节点 大于 父 节点 则 不做 处理 否则 二者 交换 if keycompareto e e gt 可以 看到 当 priorityqueue 不为 空 时 插入 一个 新元素 会对 其 新元素 进行 堆排序 处理 对于 堆排序 此处 不做 描述 这样 每次 进来 都 会对 该 元素 进行 堆排序 运算 这样 也就 保证 了 queue 中 第一个 元素 永远是 最小 的 默认 规则 排序 pool 方法 publicepoll if size e queuessize 即 原来 数组 的 最后 一个 元素 ex e s siftdown x returnresult 此处 可知 当 取出 一个 值 进行了 siftdown 操作 传入 的 参数 为 索引 和 队列 中 的 最后 一个 元素 intkex klthalf intchild kltlt 和 right 是 parent 的 两 个子 节点 找出 小 的 那个 成为 新 的 c c compareto e queueright gt keycompareto e c lt break 小 的 变 成了 新 的 父 节点 当 没有 comparator 比较 器 是 采用 的 siftdown 方法 如上 因为 索引 位置 取 出了 找 索引 的 子 节点 比它 小 的 作为 新 的 父 节点 并在 循环 内 递归 priorityqueue 是不是 很简单 呢 其他 细节 就 不再 详解 待 诸君 深入 是 java 中 基于 数组 实现 的 双 端 队列 在 java 中 deque 的 实现 有 linkedlist 和 arraydeque 正如 它 两 的 名字 就 标志 了 它们 的 不同 linkedlist 是 基于 双向 链表 实现 的 而 arraydeque 是 基于 数组 实现 的 arraydeque 的 继承 关系 可见 arraydeque 是 deque 接口 的 实现 和 linkedlist 不同 的 是 linkedlist 既是 list 接口 也是 deque 接口 的 实现 arraydeque 使用 案 列 dequeoffer aaa dequeoffer bbb dequeoffer ccc dequeoffer ddd peek 方法 只 获取 不 移除 dequepeekfirst dequepeeklast 案例 二 dequeofferfirst aaa dequeofferlast bbb dequeofferfirst ccc dequeofferlast ddd stringawhile adequepolllast null systemerrprint agt 上述 程序 最后 得到 队列 中 排列 结果 为 cccaaabbbddd 所以 循环 使用 polllast 结果 dddbbbaaaccc 图示 案 列 二 的 插入 逻辑 如下 arraydeque 内部 组成 具体 存放 元素 的 数组 数组 大小 一定 是的 幂 次方 队列 头 索引 队列 尾 索引 默认 的 最小 初始化 容量 即 传入 的 容量 小于 容量 为 而 默认 容量 是 数组 elements 长度 此处 elements 数组 的 长度 永远 是的 幂 次方 此处 的 实现 方法 和 hashmap 中 基本 一样 即 保证 长度 的 二进制 全部 由 组成 然后 再加 则 变 成了 故 一定 是的 幂 次方 intnumelements initialcapacity initialcapacity initialcapacity initialcapacity 实现 机制 如 下图 所示 此处 应将 数组 视作 首尾相连 的 最初 头部 和 尾部 索引 都是 addlast 方向 往右 addfirst 方向 往左 所以 数组 中间 可能是 空 的 当头 指针 和 尾 指针 相遇 的 时候 对 数组 进行 扩容 并 对 元素 位置 进行 调整 源码 ee if enull elementshead head amp elementslength eif headtail doublecapacity 注意 下边 这行 代码 表示 当 head 大于 等于 时 headhead 否则 head amp elementslength 换一种 写法 就是 下边 这样 是不是 就是 上边 addfirst 的 指针 移动 方向 这个 就是 位 运算 的 神奇 操 作了 因为 任何 数 与 大于 它 的 一个 全是 二进 制做 amp 运算 时 等于 它 自身 如 amp 此处 不 赘述 再看 addlast 方法 ee if enull elementstaileif tail tail amp elementslength head doublecapacity 同样 的 注意 有 一串 神奇 代码 tail tail amp elementslength 该 表达式 等于 是不是 很 神奇 的 写法 其 原理 是 一个 二进制 数 全部 由 组成 和 一个 大于 它 的 数 做 amp 运算 结果 为 如 amppoll 方法 和 add 方法 逻辑 是 相反 的 此处 就 不再 赘述 诸君 共 求 之 set 如果说 list 对 集合 加了 有序性 的 化 那么 set 就是 对 集合 加 上了 唯一性 set 接口 java 中 的 set 接口 和 colletion 是 完全 一样 的 定义 booleanisempty objecttoarray lttgtttoarray ta ee booleanremove objecto collectionltgtc booleanaddall collectionltgtc collectionltgtc voidclear booleanequals objecto inthashcode 此处 和 collection 接口 由 区别 hashsetjava 中 的 hashset 如其 名字 所示 其 是 一种 hash 实现 的 集合 使用 的 底层 结构 是 hashmaphashset 继承 关系 hashset 源码 publichashset publichashset mathmax int csize f addall c publichashset publichashset initialcapacity hashset returnmapkeyset iterator publicintsize returnmapsize objecto o ee returnmapput epresent objecto returnmapremove o mapclear 可以 看到 hashset 内部 其实是 一个 hashmaphashset 是 如何 保证 不 重复 的 呢 可见 hashset 的 add 方法 插入 的 值 会 作为 hashmap 的 key 所以是 hashmap 保证 了 不 重复 map 的 put 方法 新增 一个 原来 不存在 的 值 会 返回 null 如果 原来 存在 的话 会 返回 原来 存在 的 值 关于 hashmap 是 如何 实现 的 见 后续 用 的 也 比 较少 其 也是 基于 set 的 实现 linkedhashset 继承 关系 和 hashset 一样 其 也是 set 接口 的 实现 类 并且是 hashset 的 子类 linkedhashset 源码 调用 hashset 的 构造 方法 super super super ftrue super mathmax csize ftrue addall c 其 操作方法 和 hashset 完全 一样 那么 二者 区别 是什么 呢 首先 linkedhashset 是 hashset 的 子类 linkedhashset 中 用于 存储 值 的 实现 linkedhashmap 而 hashset 使用 的 是 中 调用 的 父 类 构造 器 可以 看到 其实 列 是 一个 linkedhashset 的 实现 很简单 更 深入 的 了解 需要 去看 linkedhashmap 的 实现 对 linkedhashmap 的 解析 将 单独 提出 mapmap 是 一种 键值 对 的 结构 就是 常说 的 keyvalue 结构 一个 map 就是 很多 这样 kv 键值 对 组成 的 一个 kv 结构 我们 将其 称作 entry 在 java 里 map 是 用 的 非常 多 的 一种 数据结构 上图 展示 了 map 家族 最 基础 的 一个 结构 只是 指 javautil 中 整 理了 年 java 面试题 map 接口 booleanisempty objectkey objectvalue vget objectkey kkeyvvalue vremove objectkey voidclear setltkgtkeyset vgetvalue vsetvalue vvalue booleanequals objecto inthashcode return cc gtcgetkey compareto cgetkey return cc gtcgetvalue compareto cgetvalue cmp return cc gtcmpcompare cgetkey cgetkey cmp return cc gtcmpcompare cgetvalue cgetvalue objecto inthashcode vvreturn vget key null containskey key action for ventrygetvalue catch ise actionaccept kv function for ventrygetvalue catch ise kv v catch ise kkeyvvalue vvget key if vnull vput keyvalue key if objectsequals curvaluevalue key key key if objectsequals key returnfalseput keynewvalue kkeyvvalue vcurvalueif curvalueget key null containskey key curvalueput keyvalue mappingfunction vvif vget key null vnewvalueif key null put keynewvalue voldvalueif oldvalueget key null keyoldvalue if newvaluenull put keynewvalue key voldvalueget key keyoldvalue if newvaluenull deletemappingif key key keynewvalue value voldvalueget key vnewvalue oldvaluenull oldvaluevalue if newvaluenull remove key elseput keynewvalue 接口 本身 就是 一个 顶层 接口 由 一堆 map 自身 接口 方法 和 一个 entry 接口 组成 entry 接口 定义 了 主 要是 关于 keyvalue 自身 的 一些 操作 map 接口 定义 的 是 一些 属性 和 关于 属性 查找 修改 的 一些 接口 方法 hashmaphashmap 是 java 中最 常用 kv 容器 采 用了 哈希 的 方式 进行 实现 hashmap 中 存储 的 是 一个又一个 keyvalue 的 键值 对 我们 将其 称作 entryhashmap 对 entry 进行了 扩展 称作 node 使其 成为 链表 或者 树 的 结构 使其 存储 在 hashmap 的 容器 里 是 一个 数组 hashmap 继承 关系 hashmap 存储 的 数据 map 接口 中有 一个 entry 接口 在 hashmap 中 对 其 进行了 实现 entry 的 实 现是 hashmap 存放 的 数据 的 类型 其中 entry 在 hashmap 的 实 现是 nodenode 是 一个 单 链表 的 结构 treenode 是 其 子类 是 一个 红 黑 树 的 类型 其 继承 结构图 如下 hashmap 存放 数据 的 数据 是什么 呢 代码 中 存放 数据 的 容器 如下 说 明了 该 容器 中 是 一个又一个 node 组成 而 node 有 三种 实现 所以 hashmap 中 存放 的 node 的 形式 既可 以是 node 也 可 以是 treenodehashmap 的 组成 有 了 上边 的 概念 之后 来看 一下 hashmap 里 有 哪些 组成 吧 是 hashmap 的 最小 容量 容量 就是 数组 的 大小 也 就是 变量 最大 数量 该 数组 最大值 为 一 次方 默认 的 加载 因子 如果 构造 的 时候 不 传 则为 一个 位置 里 存放 的 节点 转化成 树 的 阈值 也 就是 比如 数 组里 有 一个 node 这个 node 链表 的 长度 达到 该 值 才会 转 化为 红 黑 树 当 一个 反 树 化 的 阈 值当 这个 个 node 长度 减少 到 该 值 就会 从 树 转化成 链表 满足 节点 变成 树 的 另一个 条件 就是 存放 node 的 数组 长度 要 达到 具体 存放 数据 的 数组 一个 存放 kv 缓冲区 是 指 hashmap 中 存 放了 多少个 键值 对 对 map 的 修改 次数 加载 因子 这儿 要说 两个 概念 table 是 指 的 存放 数据 的 数组 bin 是 指 的 table 中 某一个 位置 的 node 一个 node 可以 理解 成 一批 一盒 数据 hashmap 中 的 构造 函数 只有 容量 this publichashmap mfalse intsmsize if sgt if tablenull presizefloatft float sloadfactor fintt ftlt float maximumcapacity int if tgtthreshold t elseif sgtthreshold resize for kkeyegetkey vvalueegetvalue putval hash key publichashmap if 容量 不 能为 负数 当 容量 大于 就 取 最大值 ltltif loadfactor 当前 数组 table 的 大小 一 定是 是的 幂 次方 tablesizefor 保证 了 数组 一 定是 是的 幂 次方 是 大于 initialcapacity 最 结 进 的 值 initialcapacity tablesizefor 方法 保证 了 数组 大小 一 定是 是的 幂 次方 是 如何 实现 的 呢 intcap nlt 该 方法 将 一个 二进制 数 第一位 后边 的 数字 全部 变成 然后 再加 这样 这个 二进制 数 就 一 定是 这样 的 形式 此处 实 现在 arraydeque 的 实现 中 也 用 到了 类似 的 方法来 保证 数组 长度 一定 是的 幂 次方 put 方法 开发人员 使用 的 put 方法 publicvput kkeyvvalue returnputval hash key 真正 hashmap 内部 使用 的 put 值 的 方法 finalvputval tabtable null ntablength n tabresize length 当 hash 到 的 位置 该 位置 为 null 的 时候 存放 一个 新 node 放入 这儿 p 赋值 成了 table 该 位置 的 node 值 if ptabi n amphash null tabinewnode 该 位置 第一个 就是 查 找到 的 值 将 p 赋 给 eif phashhashampamp kpkey key k ep 如果是 红 黑 树 调用 红 黑 树 的 puttreeval 方法 elseif e treenodeltkvgt p puttreeval else 是 链表 遍历 注意 epnext 这个 一直 将 下一 节点 赋值 给 e 直到 尾部 注意 开头 是 bincountfor if epnext null pnextnewnode 当 链表 长度 大于 等于 插入 第 位 树 化 if forsttreeifybin tabhash breakif ehashhashampamp kekey key k breakpeif enull e sizegtthreshold resize evict returnnull 查找 方法 先 判断 表 不为 空 if tabtable nullampamp ntablength gtampamp 这一 行 是 找到 要 查询 的 key 在 table 中 的 位置 table 是 存放 hashmap 中 每一个 node 的 数组 firsttab n amphash null node 可能是 一个 链表 或者 树 先 判 断根 节点 是否 是 要 查询 的 key 就是 根 节点 方便 后续 遍历 node 写法 并且 对于 只有 根 节点 的 node 直接判断 if kfirstkey key k returnfirst 有 子 节点 if efirstnext null 红 黑 树 查找 if return treenodeltkvgt first gettreenode hashkey do 链表 查找 if ehashhashampamp kekey key k returne 遍历 链表 当 链表 后续 为 null 则 推出 循环 while eenext null 和 hashmap 不同 hashtable 的 实现 方式 完全 不同 这点 从 二者 的 类 继承 关系 就可以 看出 端倪 来 hashtable 和 hashmap 虽然 都 实现 了 map 接口 但是 hashtable 继承 了 dictionary 抽象类 而 hashmap 继承 了 abstractmap 抽象类 hashtable 的 类 继承 关系 图 接口 objectkey kkeyvvalue objectkey dictionary 类 中有 这样 一行 注释 当 key 为 null 时会 抛出 空 指针 这也 说 明了 hashtabel 是 不允许 key 为 null 的 组成 真正 存放 数据 的 数组 int 重新 hash 的 阈值 中 的 元素 存在 entryltgttable 中 是 一个 entry 数组 entry 是 存放 的 节点 每一个 entry 是 一个 链表 hashtable 中 的 知道 entry 是 一个 单 链表 即可 和 hashmap 中 的 node 结构 相同 但是 hashmap 中 还有 node 的 子类 treenodeput 方法 kkeyvvalue valuenull 在 数组 中 的 位置 xfffffff 是 位 二进制 intindex hashampxfffffff unchecked entryltkvgt tabindexfor 如果 遍历 链表 找 到了 则 替换 旧 值 并 返回 if entryhashhash key returnnull 本质上 就是 先 hash 求 索引 遍历 该 索引 entry 链表 如果 找到 hash 值 和 key 都 和 put 的 key 一样 的 时候 就 替换 旧 值 否则 使用 addentry 方法 添加 新 值 进入 table 因为 添加 新元素 就 涉及到 修改 元素 大小 还 可能 需要 扩容 等 具体 看 下边 的 addentry 方法 可知 如果 扩容 需要 重新 计算 hash 所以 index 和 table 都 会被 修改 if index hashampxfffffff unchecked entryltkvgte entryltkvgt tabindex 插入 新元素 hashkeyvaluee hashkeyvaluee 这行 代码 是 真正 插入 新元素 的 方法 采用 头 插 法 单 链表 一般 都用 头 插 法 快 get 方法 unchecked objectkey intindex hashampxfffffff tablengthfor if ehashhash key return v 方法 就 简单 很多 就是 hash 找到 索引 遍历 链表 找到 对应 的 value 没有 则 返回 null 相比 诸君 都 已经 看到 hashtable 中 方法 是 用 synchronized 修饰 的 所 以其 操作 是 线程 安全 的 但是 效率 会受 影响 