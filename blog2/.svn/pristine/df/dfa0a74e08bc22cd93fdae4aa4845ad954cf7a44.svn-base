万字 长文 解析 cglib 动态 代理 源码 文章 目录 前言 cglib 代码 示例 源码 阅读 cglib 代理 类 的 生成 步骤 cglib 通过 什么 方式 调用 代理 类 的 方法 呢 学 而 思 总结 前言 上 一篇 文章 我们 讲了 jdk 动态 代理 及 相关 源码 解析 我们 了 解了 jdk 动态 代理 的 基本原理 jdk 动态 代理 只 代理 接口 而 cglib 可以 代理 任意 一个 目标 类 对 final 类 和 方法 无法 代理 本文 我们 将 探索 cglib 如何 使用 及 底层 逻辑 cglibcglib 是 一个 强大 高性能 高质量 的 code 生成 类 库 它 可以 在运 行期 扩展 java 类 实现 java 接口 代码 示例 给 目标 账户 执行 转账 transferamount 元 给 客户 取款 withdrawamount 元 代理 类 parammethod 拦截 的 方法 paramobjects 参数 数组 对 方法 的 代理 false oobjects operation true 业务 处理完毕 收起 银行卡 开始 业务 操作 currentstatus 将 执行 过程中 通过 cglib 动态 生成 的 class 文件 保 存到 本地 stringargs atmatmnewatm 设置 父 类 基于 business 生成 代理 子类 bankclass 设置 回 调 atm bankbusiness bank enhancercreate 开始 业务 操作 给 目标 账户 执行 转账 元 业务 处理完毕 收起 银行卡 开始 业务 操作 给 客户 取款 元 业务 处理完毕 收起 银行卡 源码 阅读 cglib 代理 类 的 生成 步骤 首先 我们 先 查看 enhancercreate 主要 做了 那些 事 代码 部分 省略 enhancerkey 设置 被 代理 的 类 如果 superclass 是 一个 接口 则 使用 setinterfaces 非 接口 实参 不能 声 明为 final 并且 必须有 一个 可以 访问 的 构造 参数 paramsuperclass 被 代理 的 类 或 接口 classsuperclass if setinterfaces elseif objectclass classinterfaces 设置 代理 类 的 方法 映 射到 特定 回 调 索引 设置 单个 回 调 setcallbacks 设置 回 调 数组 设置 该 方法 的 同时 必须 使用 callbackfilter 来 指定 代理 类 中 每个 方法 在 对应 的 回 调 索引 if 生成 代理 类 并 使用 指定 回 调 return 返回 代理 类 实例 prevalidate superclassnull interfaces filter key returnresult 代码 部分 省略 调用 enhancercreate 时 大致 流程 如下 调用 createhelper 方法 然后 进行 前置条件 检查 调用 enhancer 内部 接口 enhancerkey 的 newinstance 生成 唯一 key 用于 从 缓存 中 获取 代理 类 实例 然后 通过 supercreate key 获取 我们 设置 的 superclass 对应 的 代理 类 实例 下面 我们 继续 跟进 源码 如下 部分 省略 objectkey try 获得 类 加载 器 loader 作为 缓存 根据 类 加载 器 获取 缓存 loader if datanull synchronized loader if datanull cache loader newcacheput loaderdata 默 认为 true 用于 设 值 是否 启用 缓存 thisgetusecache if 实例 化 并 返回 class obj obj catch throwecatch errore throwecatch exceptione e 省略 部分 代码 key 流程 大致 如下 通过 类 加载 器 从 cache 中 获取 对应 缓存 若 根据 类 加载 器 未获 取到 缓存 则 初始化 后 放入 缓存 部分 代码 片段 loader if datanull cache loader newcacheput loaderdata 是 的 内 部类 通过 dataget thisgetusecache 从 缓存 获取 class 实例 或 通过 asm 生成 字节 码 文件 返回 class 实例 最后 一步 很 关键 dataget thisgetusecache 源码 如下 内 部类 classloaderdata 源码 部分 代码 省略 部分 代码 省略 if classloadernull classloader 生成 字节 码 文件 载入 并 初始化 返回 class 实例 klass getkeyload publicobjectget 判断 是否 通过 缓存 获取 if usecache gen cachedvalue dataget thisgetusecache 大致 流程 如下 usecachetrue 则 gen 从 缓存 获取 若 缓存 不存在 则 通过 gengenerate 创建 class 实例 后 放入 缓存 部分 源码 部分 省略 v 代理 类 的 classkk 生成 key 的 类 kkey 生成 cachekey 并从 中 获取 代理 类 的 key objectvmapget cachekey if vnullampamp return v v 未获 取到 则 创建 class 并 放入 缓存 keycachekeyv 代码 部分 省略 publicvcall throwsexception 生成 key cachekeytask if prevtasknull elseif task futuretaskltvgt v 代码 部分 省略 if creator 放入 缓存 mapput cachekeyresult key 的 实 现是 在 classloaderdata 构造 方法 中 klass 否则 直接 gengenerate 生成 字节 码 文件 载入 并 初始化 返回 class 实例 ok 继续 跟进 gengenerate 这块 的 代码 逻辑 部分 代码 片段 currentset this if classloadernull synchronized classloader 生成 类 名 datareservename name name 通过 类 加载 器 尝试 加载 getclassname 加载 不到 抛出 异常 继续 向下 执行 if attemptload classnamefalse 将 字节 码 文件 加 载到 jvm 中 false 标识 不 进行 连接 即 不 会被 初始化 默认 除了 将 字节 码 文件 加 载到 jvm 中 true 标识 自动 初始化 默 认为 getclassname returngencatch ignore 生成 字节 码 数组 this newclassreader b synchronized classloader justincase 将上 面 生成 的 字节 码 加 载到 内存 返回 class 实例 classforname if returngencatch throwecatch errore throwecatch exceptione e save 大致 流程 如下 生成 类 名称 生成 规则 类 全 限 定名 来源 进制 的 hash 值 部分 代码 片段 if prefixnull java gettag namesevaluate attempt 通过 类 加载 器 尝试 加载 上面 生成 的 类 名称 成功 就 返回 失败 则 继续 执行 通过 asm 框架 工具 类 生成 字节 码 数组 涉及 的 内容 较多 本文 不 展开 阅读 通过 classforname 转 换为 部分 源码 defineclassnull newinteger blength class loaderargs elseif newinteger blength class unsafeargs throwable returnc 至此 cglib 生成 代理 类 的 流程 我们 通过 以上 源码 都 大致 了 解了 那么 它 的 调用 过程 呢 cglib 通过 什么 方式 调用 代理 类 的 方法 呢 在 代码 示例 中 我们 通过 配置 的 值 来 保存 cglib 生成 的 文件 查看 对应 路径 下 的 文件 如下 输出 路径 代理 类 的 fastclass 类 代理 类 被 代理 的 fastclass 类 接下来 我们 先 查看 生成 的 代理 类 源码 我 是 通过 idea 打开 可以 自行 选择 通过 设置 的 对应 拦截器 代理 类 方法 每个 方法 对应 一个 method 及 初始化 newstringequals ljavalangobject ztostring iclone ljavalangobject varclassforname javalangobject varvar ljavalangobject varvar varvar varvar 获取 父 类 的 方法 ljavalangstring vwithdraw ljavalangstring v varclassforname demobank varvar ljavalangstring varvar ljavalangstring 直接 调用 父 类 方法 stringvar supertransfer var 设置 了 拦截器 则 调用 对应 拦截器 的 intercept 方法 stringvar varnull this varnull varintercept var 如上 类似 stringvar superwithdraw var 如上 类似 stringvar varnull this varnull varintercept var 省略 clone tostring hashcode equals 部分 源码 signaturevar switch varhashcode caseif varequals withdraw ljavalangstring v 部分 省略 caseif varequals transfer ljavalangstring v 部分 省略 this callbackvar objectvar varif varcglibbound if varnull varnull callback var 部分 省略 回顾 一下 我们 的 示例 代码 demo 示例 中 我们 通过 enhancercreate 获得 代理 类 实例 如上 源码 在 初始化 的 过程中 会为 每个 方法 生成 对应 的 method 与 接下来 调用 transfer 方法 时 判断 是否 设置 拦截器 在 设置 拦截器 的 情况下 判断 分 支会 执行 到 varintercept 部分 源码 stringvar 指定 的 拦截器 否则 非 varnull this varnull 参数 释义 分 别是 代理 类 拦截 的 方法 参数 方法 代理 varintercept var 然后 调用 拦截器 atmintercept 方法 打印 开始 业务 操作 增强 的 对象 parammethod 拦截 的 方法 paramobjects 参数 数组 对 方法 的 代理 false oobjects operation true 业务 处理完毕 收起 银行卡 开始 业务 操作 currentstatus 然后 通过 oobjects 调用 父 类 方法 oobjects 如何 调用 父 类 方法 呢 方法 签名 被 代理 对象 paramc 代理 对象 paramdesc 参数 描述 paramname 被 代理 方法 paramname 代理 方法 namedesc namedesc cc 被 代理 对象 代理 对象 被 代理 对象 方法 索引 inti 代理 对象 方法 索引 classcclassc if 部分 代码 省略 被 代理 类 fastclass 通过 被 代理 对象 方法 索引 调用 代理 类 方法 fciiobjargs catch catch if throwe 代理 类 fastclass 通过 代理 对象 方法 索引 实际 调用 代理 类 父 类 方法 paramobj 代理 类 paramargs 参数 数组 初始化 init 调用 代理 对象 fastclassinvoke 方法 也 就是 我们 上面 看到 的 生成 文件 对象 fciiobjargs catch 创建 被 代理 对象 fastclassf 代理 对象 fastclass f 被 代理 对象 方法 i 代理 对象 方法 if synchronized initlock if fcifhelper cicic fcifhelper cicic sig sig oobjects 大致 流程 如下 init 创建 被 代理 对象 fastclass 与 代理 对象 fastclass 获取 被 代理 对象 方法 索引 与 代理 对象 方法 索引 通过 cifinvoke fciiobjargs 代理 类 fastclass 通过 代理 对象 方法 索引 调用 代理 类 父 类 方法 打开 生成 的 代理 类 fastclass 部分 源码 如下 classvar super var signaturevar switch varhashcode 省略 caseif varequals withdraw ljavalangstring v varequals cglibtransfer ljavalangstring v returnbreak 省略 switch varhashcode caseif varequals cglibtransfer switch varlength caseif vargetname equals javalangstring varequals cglibwithdraw switch varlength caseif vargetname equals javalangstring returnbreak 省略 classvar switch varlength 方法 索引 var 代理 类 var 参数 aaa var string var string var catch throwablevar var 省略 通过 以上 代理 类 fastclass 源码 我们 可以 看到 在 调 用时 通过 方法 索引 找到 对应 方法 然后 调用 代理 类 的 cglibtransfer string var 方法 完成 最终 调用 调用 完毕 最终 输出 业务 处理完毕 收起 银行卡 至此 整个 流程 结束 代理 类 部分 源码 直接 调用 父 类 方法 stringvar supertransfer var 学 而 思 将 代码 示例 中 atm 的 修 改为 将会 导致 这是 什么原因 呢 有 兴趣 的 同学 可以 自行 研究一下 找到 对应 的 解决 方式 总结 通过 源码 阅读 的 方式 我们 了 解了 代理 类 生成 的 生成 逻辑 与 最终 如何 调用 被 代理 类 目标 方法 的 逻辑 形 成了 对 cglib 从 模糊 到 清晰 的 印象 