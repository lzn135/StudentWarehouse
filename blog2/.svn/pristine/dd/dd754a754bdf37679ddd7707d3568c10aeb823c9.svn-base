lock condition 的 那些 事儿 lockcondition 是 java 中 提供 的 等待 通知 机制 使用 condition 的 await 和 signal 类似于 基于 synchronized 的 wait 和 notify 二者 都可以 实现 等待 通知 机制 但是 这两者 在 使用 和 实现 方式 上 还是 有 差别 的 比如 等待 通知 机制 涉及到 同步 队列 和 等待 队列 object 的 waitnotify 只能 拥有 一个 等待 队列 而 condition 可以 拥有 多个 等待 队列 waitnotify 的 等待 队列 管理 是 由 jvm 控制 的 而 condition 的 是 由 jdkjuc 实现 的 waitnotify 同步 队列 流程图 condition 的 同步 队列 流程图 lockcondition 示例 代码 如下 stringargs gtlocklock getname awaitok catch t tstart gtlocklock try 将 等待 队列 节点 移 动到 aqs 同步 队列 中 尾部 conditionsignal getname signalok finally 唤醒 aqs 同步 队列 中 阻塞 的 线程 lockunlock t tstart 注意 await 和 signal 必 须在 lock 中 这是 为了 保证 操作 等待 队列 和 同步 队列 的 原子 性 并且 await 有 一个 释放 状态 也 就是 unlock 的 操作 下面 就以 上述 示例 代码 为 例 来 分析 下 condition 的 await 和 signal 流程 对于 线程 t 来说 执行 到 await 方法 时会 添加 一个 节 点到 等待 队列 中 然后 释放 当前 state 唤醒 其他 线程 最后 阻塞 自己 等待 被 唤醒 添加 节 点到 等待 队列 该 方法 未 考虑 场景 因此 需 在 lock 中 释放 当前 aqsstate 会 唤醒 同步 队列 中 等待 的 线程 node isonsyncqueue node 不再 同步 队列 中 当前 线程 阻塞 等待 被 唤醒 locksupportpark this if node break 唤醒 后 重新 获取 state 获取 成功 后 退出 if acquirequeued nodesavedstate if interruptmode interruptmode 当 其他 线程 执行 到 signal 时会 将 之前 在 等待 队列 中 的 节点 移 动到 同步 队列 中 最后 执行 unlock 时 唤醒 同步 队列 中 的 线程 当前 占用 state 不是 自己 抛 异常 if 开始 唤醒 第一个 节点 firstnull dosignal first 唤醒 第一个 处于 nodecondition 的 节点 因为 有些 node 可能 由于 超时 处于 其他 状态 就 没有必要 唤 醒了 nodefirst doif null first ampamp null nodenode 重置 节点 state 马上 就要 进入 同步 队 列了 if returnfalse 进入 同步 队列 如果 前 一个 节点 stategt 需要 nodepenq node 表示 前 一个 节点 状态 不对 需要 设置 为 signal 好 唤醒 新 加入 的 节点 nodeif pwsnodesignal nodethread 如果 cas 设置 失败 只能 先 唤 醒了 接口 方法 如下 所示 await 多了 一些 超时 等待 机制 signalall 底层 和 signal 是 一样 的 这里 就 不在 展开 至此 lockcondition 相关 核心 代码 已 分析 完毕 由于 condition 和 相关 因此 关于 aqs 的 资料 可以 参考 aqs 是 如何 控制 线程 的 关于 的 可以 参考 浅谈 synchronized 与 原理 推荐 阅读 aqs 是 如何 控制 线程 的 浅谈 synchronized 与 原理 java 线程 的 那些 状态 们 如何 优雅 的 让 个 线程 打印 abcddd 的 领域 概念 们 如何 解决 大 分页 查询 问题 从 侵入 式 服务 治 理到 servicemesh 