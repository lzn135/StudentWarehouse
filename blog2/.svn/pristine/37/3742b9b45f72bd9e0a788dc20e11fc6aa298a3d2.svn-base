java 并发 组件 浅析 戳 蓝字 topcoder 关注 我们 哦 java 并发 相关 组件 或者 技术 包括 线程 线程 池 阻塞 队列 队列 同步器 并发 工具 类 原子 更新 类 等 下面 我们 以 总体 视角 来 看下 这些 组件 之间 的 依赖 关系 imagepngjava 线程 池 核心 功能 就是 线程 管理 和 任务 存储 其 底层 基于 阻塞 队列 来 完成 线程 池 是 日常 开发 中 使用 较多 的 并发 组件 其 带来 的 好处 有 降低 资源 消耗 通过 重复 利用 已 创建 的 线程 降低 线程 创 建和 销毁 造成 的 消耗 提高 响应速度 当 任务 到达 时 任务 可以 不需要 等到 线程 创建 就能 立即 执行 提高 线程 的 可管理性 线程 是 稀缺资源 如果 无限制 地 创建 不仅 会 消耗 系统资源 还会 降低 系统 的 稳定性 使用 线程 池 可以 进行 统一分配 调 优 和 监控 但是 要做到 合理 利用 线程 池 必须 了解 其 实现 原理 代码 解 耦 比如 生产者 消费者 模式 阻塞 队列 主要 包括 两部分 内容 一个是 存放 数据 的 容器 另一个 就是 线程 的 管理 阻塞 唤醒 前者 可以 基于 array 或者 linkedlist 数据结构 后者 借助于 lockcondition 来 实现 也 就是 使用 通知 模式 来 实现 的 futuretask 用于 在 异步 操作 场景 中 futuretask 作为 生产者 执行 futuretask 的 线程 和 消费者 获取 futuretask 结果 的 线程 的 桥梁 如果 生产者 先生 产 出了 数据 那么 消费者 get 时 能 会 直接 拿到 结果 如果 生产者 还未 产生 数据 那么 get 时会 一直 阻塞 或者 超时 阻塞 一 直到 生产者 产生 数据 唤醒 阻塞 的 消费者 为止 关于 可 参考 futuretask 原理 剖析 lockcondition 是 java 中 提供 的 等待 通知 机制 使用 condition 的 await 和 signal 类似于 基于 synchronized 的 wait 和 notify 二者 都可以 实现 等待 通知 机制 condition 的 同步 队列 流程图 关于 lockcondition 具体 可 查看 lockcondition 的 那些 事儿 队列 同步器 是 构建 juc 中 锁 和 其他 同步 组件 的 基础 组件 我们 在 日常 开发 中 一般 不会 直接 与 aqs 打交道 aqs 核心 功能 就 点 通过 cas 维护 state 状态 通过 cas 维护 同步 队列 进而 控制 线程 的 阻塞 唤醒 换句话说 就是 aqs 使用 一个 int 成员 变量 表示 同步 状态 通过 内置 的 fifo 队列 来 完成 资源 获取 线程 的 排队 工作 并 发包 的 作者 douglea 期望 它 能够 成为 实现 大部分 同步 需求 的 基础 aqs 是 一个 抽象类 但是 并没有 抽象 方法 只不过 有些 方法 是 会 抛出 这些 方法 就需要 根据 不同 场景 进行 子类 重写 比如 可 重入 锁 就 重 写了 方法 等 子类 重写 这些 方法 可 自定义 对应 逻辑 比如 判断 是否 可 重入 是否 公平 设置 state 等 这块 具体 代码 参考 类 源码 即可 locksupport 定义 了 一组 的 公共 静态 方法 这些 方法 提供 了 最基本 的 线程 阻塞 和 唤醒 功能 而 locksupport 也 被称为 构建 同步 组件 的 基础 工具 locksupport 定义 了 一组 以 park 开头 的 方法 用来 阻塞 当前 线程 以及 unpark threadthread 方法来 唤醒 一个 被 阻塞 的 线程 locksupport 提供 的 阻塞 和 唤醒 方法 如下 imagepng 关于 locksupport 更多 资料 可 参考 为什么 说 locksupport 是 java 并发 的 基石 java 并发 工具 类 主要有 和 exchanger 日常 开发 中 经常 使用 的 是 countdownlatch 和 semaphore 他们 都是 基于 aqs 或者 lockcondition 等 来 实现 的 具体 资料 可 参考 java 并发 工具 那些 事儿 推荐 阅读 lockcondition 的 那些 事儿 aqs 是 如何 控制 线程 的 浅谈 synchronized 与 原理 java 线程 的 那些 状态 们 如何 优雅 的 让 个 线程 打印 abc 