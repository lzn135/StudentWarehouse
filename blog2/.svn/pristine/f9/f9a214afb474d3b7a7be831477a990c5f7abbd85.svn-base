面试题 mybatis 中 的 dao 接口 和 xml 文件 里 的 sql 是 如何 建立 关系 的 微 信 搜索 程序员 囧 辉 关注 这个 坚持 分享 技术 干货 的 程序员 目录 前言 正文 解析 代码 块 registerfilters 代码 块 doscan 解析 代码 块 parse 代码 块 代码 块 代码 块 解析 dao 文件 dao 接口 被 调用 代码 块 invoke 代码 块 增 删改 查 总结 前言 这是 mybatis 比较 常 问到 的 面试题 我 自己 在 以前 的 面试 过程 中被 问 到了 次次 都是 非常重要 的 面试 环节 因此 自己 印象 很 深刻 这个 题目 我 很 早就 深入 学习 了 但是 一直 没有 整理出来 刚好 最近 一段时间 由于 工作 太忙 大概有 半年 没有 技术文章 产出 因此 趁着 五一 有点 时间 整 理了 下 分享 给 大家 另外 估计 不少 同学 应该 也 注意 到了 dao 接口 的 全 路径名 和 xml 文件 中 的 sql 的 namespaceid 是 一样 的 其实 这 也是 建立 关联 的 根本原因 本 文中 的 源码 使用 当前 最新 的 版本 即 mybatisspring 为 mybatis 为 引入 这个 jar 包 即可 查 看到 本文 的 所有 代码 正文 当 一个 项目 中使 用了 spring 和 mybatis 时 通常 会有 以下 配置 当然 现在 很多 项目 应该 都是 springboot 了 可能 没有 以下 配置 但是 究其 底层 原理 都是 类似 的 无非是 将 扫描 bean 等 一些 工作 通过 注解 来 实现 ltdao 接口 所在 包 名 spring 会 自动 查找 其下 的 类 指 定要 扫描 的 包 在此 包 之下 的 映射器 都 会被 搜索 到 可 指定 多个 包包 与 包 之间 用 逗号 或 分号 分隔 和 mybatis 完美 整合 不需要 mybatis 的 配置 映射 文件 自动 扫描 mappingxml 文件 通常 我们 还会 有 dao 类 和 对 用 的 mapper 文件 如下 integerid 解析 是 一个 会在 spring 构建 ioc 容器 的 早期 被 调用 重写 的 方法 参考 详解 if 新建 一个 并 填充 相应 属性 registry thisaddtoconfig if 设置 mapperbean 是否 需要 懒 加载 booleanvalueof 注册 filter 因为 上面 构造 函数 我们 没有 使用 默认 的 filter 有 两种 要 扫描 的 excludefilters 要 排除 的 扫描 可通过 tn 来 填写 多个 重 写了 doscan 方法 scannerscan 注册 filter 见 代码 块 扫描 basepackage 这边 会 走到 的 父 类 然后 在 执行 doscan basepackages 时 回到 重写 的 方法 见 代码 块 代码 块 如果 指定 了 注解 则将 注解 添加到 如果 指定 了 标记 接口 则将 标记 接口 添加到 includefilters 但 这边 重 写了 matchclassname 方法 并 返 回了 false 相当于 忽略 了 标记 接 口上 的 匹配 项 所以 该 参数 目前 相当于 没有 任何 作用 if stringclassname returnfalse 如果 没有 指定 annotationclass 和 markerinterface 则 添加 默认 的 includefilters 直接 返回 true 接受 所有 类 if gttrue 添加 默认 的 excludefilters 排 除以 packageinfo 结尾 的 类 getclassname packageinfo 通常 我们 都不会 指定 annotationclass 和 markerinterface 也 就是 会 添加 默认 的 filter 相当于 会 接受 除了 packageinfo 结尾 的 所有 类 因此 basepackage 包下 的 类 不需要 使用 component 注解 或 xml 中 配置 bean 定义 也 会被 添加到 ioc 容器 中 代码 块 直接 使用 父 类 的 方法 扫描 和 注册 bean 定义 之前 在 spring 中 已经 介绍 过 代码 块 basepackages if loggerwarn basepackages else 对 扫 描到 的 beandefinitions 进行 处理 主要 件事 将 bean 的 真正 接口 类 添加到 通用 构造 函数 参数 中将 beanclass 直接 设置 为 结合 相当于 要 使用 的 构造 函数 是 添加 属性 和 中 优先 使用 添加 属性 同样 的 优 先于 beandefinitions 小结 解析 主 要是 做了 几件事 新建 扫描器 使用 扫描 注册 basepackage 包下 的 所有 bean 将 basepackage 包下 的 所有 bean 进行 一些 特殊 处理 beanclass 设置 为 的 真正 接口 类 作为 构造 函数 参数 传入 为 添加 和 属性 解析 对于 来说 实现 了 个 接口 和 factorybean 看过 我 之前 spring 文章 的 同学 应该 对 这个 接口 不会 陌生 简单 来说 factorybean 可以 自己 定义 创建 实例 对象 的 方法 只需要 实现 它 的 getobject 方法 则是 会在 bean 初始化 阶段 被 调用 重写 这两个 接口 的 部分 方法 代码 如下 核心 代码 就 一个 方法 如果 之前 没有 构建 则 这边 也 会 调用 进行 构建 操作 throwsexception 省略 部分 代码 构建 主要 做了 几件事 对 我们 配置 的 参数 进行 相应 解析 使用 配置 的 参数 构建 一个 configuration 使用 configuration 新建 一个 这边 的 核心内容 是 对于 mapperlocations 的 解析 如下 代码 throwsexception 省略 部分 代码 mapper 处理 最 重要 if if loggerwarn elsefor if continuetry 新建 解析 mapper 文件 catch exceptione reset loggerdebug elseloggerdebug 使用 构建 解析 mapper 文件 见 代码 块 代码 块 parse publicvoidparse 如果 resource 没被 加载 过 才 进行 加载 if resource 解析 mapper 文件 parserevalnode mapper 将 resource 添加到 已 加载 列表 resource 绑定 namespace 的 解析 mapper 文件 见 代码 绑定 namespace 的 mapper 见 代码 块 代码 块 xnodecontext try 获取 namespace 属性 namespace if 设置 属性 namespace 解析 等 节点 cacherefelement contextevalnode cacheref cacheelement contextevalnode cache mapperresultmap sqlelement mappersql 解析 增 删改 查 节点 封 装成 catch exceptione if null 解析 增 删改 查 节点 封 装成 listnull for 构建 try 解析 节点 catch statementparser 这边 会 一直 执行 到 见 代码 块 这边 每个 xnode 都 相当于 如下 的 一个 sql 下面 封装 的 每个 mappedstatement 可以 理解 就是 每个 代码 块 省略 所有 的 属性 解析 将 解析 出来 的 所有 参数 添加到 缓存 if 将 id 填充 上 namespace 例如 变成 idfalse 使用 参数 构建 resource resource fetchsize fetchsize timeout timeout statementtype statementtype keygenerator keygenerator keyproperty keyproperty keycolumn keycolumn databaseid databaseid lang lang resultordered resultordered resultsets resultsets resultmaps resultsettype resultsettype valueordefault usecache valueordefault cache currentcache if 使用 构建 将 mappedstatement 添加到 缓存 statement returnstatement 该 方法 会将 节点 的 属性 解析 后 封 装成 mappedstatement 放到 缓存 中 key 为 id 例如 为 mappedstatement 代码 块 if namespacenull 解析 namespace 对应 的 绑定 类型 namespace catch boundtype 不为 空 并且 configuration 还没有 添加 boundtype 则将 namespace 添加到 已 加载 列表 将 boundtype 添加到 knownmappers 缓存 boundtype classlttgttype type classlttgttype if typeisinterface if hasmapper type 将 type 和 以 该 type 为 参数 构建 的 作为 键值 对 放到 knownmappers 缓存 中去 knownmappersput type configtype parserparse loadcompleted type 主 要是 将 刚刚 解析 过 的 mapper 文件 的 namespace 放到 knownmappers 缓存 中 key 为 namespace 对应 的 classvalue 为 小结 解析 主要 做了 几件事 解析 处理 所有 属性 参数 构建 configuration 使用 configuration 新建 解析 mapperlocations 属性 的 mapper 文件 将 mapper 文件 中 的 每个 sql 封 装成 mappedstatement 放到 缓存 中 key 为 id 例如 为 mappedstatement 将 解析 过 的 mapper 文件 的 namespace 放到 knownmappers 缓存 中 key 为 namespace 对应 的 classvalue 为 解析 dao 文件 dao 文件 也 就是 basepackage 指定 的 包下 的 文件 也 就是 上文 的 上文 doscan 中 说 过 basepackage 包下 所有 bean 定义 的 beanclass 会被 设置成 而 也是 factorybean 因此 直接 看 的 getobject 方法 throwsexception 从父 类 中 拿到 这边 的 也是 doscan 中 添加 的 属性 通过 mapperinterface 获取 getmapper classlttgttype getmapper typethis typesqlsession 从 knownmappers 缓存 中 获取 knownmappersget type if try 新建 实例 sqlsession catch exceptione 构造 一个 使用 mapperproxy 来 构建 实例 对象 mapperproxy 使用 jdk 动态 代理 来 代理 要 创建 的 实例 对象 为 mapperproxy 因此 当 我们 真正 调用 时会 走到 mapperproxy 的 invoke 方法 return t 这边 代码 用到 的 等 都是 之前 添加 的 属性 小结 解析 dao 文件 主要 做了 几件事 通过 mapperinterface 从 knownmappers 缓存 中 获 取到 对象 通过 jdk 动态 代理 创建 实例 对象 为 mapperproxydao 接口 被 调用 当 dao 中 的 接口 被 调用 时会 走到 mapperproxy 的 invoke 方法 thisargs else 创建 将 放到 methodcache 缓存 调用 的 invoke 方法 method invoke catch throwablet t methodmethod 放到 methodcache 缓存 key 为 methodvalue 为 methodmgtif misdefault 方法 为 默认 方法 java 之后 接口 允许 有 默认 方法 tryif method method catch e else 正常 接口 会 走 这边 使用 构建 一个 mappermethod 封 装成 newmappermethod catch 调用 的 invoke 方法 见 代码 块 代码 块 sqlsessionargs objectresult 根据 命令 类型 执行 来 进行 相应 操作 switch commandgettype args commandgetname param args commandgetname param args commandgetname param sqlsessionargs sqlsessionargs elseif sqlsessionargs elseif sqlsessionargs args commandgetname param if ampamp equals resultgetclass result if isprimitive returnresult 这边 就 比较简单 根据 不同 的 操作 类型 执行 相应 的 操作 最 终将 结果 返回 见 代码 块 这边 的 command 是 上文 newmappermethod 时 创建 的 代码 块 增 删改 查 returnupdate trydirtytrue 从 缓存 拿到 对应 的 mappedstatement 对象 执行 更新 操作 statement parameter catch exceptione reset returnupdate select 以 executeformany 为 例 listltegtresult 参数 转换成 sql 命令 参数 args if args commandgetname paramrowbounds else 执行 查询 操作 commandgetname param 处理 返回 结果 resultgetclass if isarray result result try 从 缓存 中 拿到 对应 的 mappedstatement 对象 执行 查询 操作 statement parameter catch exceptione reset 可以 看出 最终 都是 从 缓存 中 拿到 对应 的 mappedstatement 对象 执行 相应 的 操作 这边 的 增 删改 查 不是 直接 调用 sqlsession 中 的 方法 而是 调用 中 的 方法 继而 通过 sqlsessionproxy 来 调用 sqlsession 中 的 方法 中 的 方法 主 要是 通过 sqlsessionproxy 做了 一层 动态 代理 基本 没 差别 总结 整个 流程 主要 是 以下 几个 核心 步骤 扫描 注册 basepackage 包下 的 所有 bean 将 basepackage 包下 的 所有 bean 进行 一些 特殊 处理 beanclass 设置 为 的 真正 接口 类 作为 构造 函数 参数 传入 为 添加 和 属性 解析 mapperlocations 属性 的 mapper 文件 将 mapper 文件 中 的 每个 sql 封 装成 mappedstatement 放到 缓存 中 key 为 id 例如 为 mappedstatement 并且 将 解析 过 的 mapper 文件 的 namespace 放到 knownmappers 缓存 中 key 为 namespace 对应 的 classvalue 为 创建 dao 的 bean 时 通过 mapperinterface 从 knownmappers 缓存 中 获 取到 对象 通过 jdk 动态 代理 创建 实例 对象 为 mapperproxydao 中 的 接口 被 调 用时 通过 动态 代理 调用 mapperproxy 的 invoke 方法 最终 通过 mapperinterface 从 缓存 中 拿到 对应 的 mappedstatement 执行 相应 的 操作 