2020年 java 多线程 与 并发 系列 22 道 高频 面试题 附 思维 导 图 和 答案 解析 前言 现在 不管是 大公司 还是 小公司 去 面试 都会 问到 多线程 与 并发 编程 的 知识 大家 面试 的 时候 这方 面的 知识 一 定要 提前 做好 储备 关于 多线程 与 并发 的 知识 总 结了 一个 思维 导 图 分享 给 大家 java 中 实现 多线程 有 几种 方法 继承 thread 类 实现 runnable 接口 实现 callable 接口 通过 futuretask 包装 器 来 创建 thread 线程 使用 实现 有 返回 结果 的 多线程 也 就是 使 用了 executorservice 来 管理 前面 的 三种 方式 如何 停止 一个 正在 运行 的 线程 使用 退出 标志 使 线程 正常 退出 也 就是 当 run 方法 完成后 线程 终止 使用 stop 方法 强行 终止 但是 不 推荐 这个 方法 因为 stop 和 suspend 及 resume 一样 都是 过期作废 的 方法 使用 interrupt 方法 中断 线程 while stop getname isrunning trysleep catch weekupfromblcok stoptrue 在 异常 处理 代码 中 修改 共享 变量 的 状态 getname isexiting stringargs startingthread mstart threadsleep minterrupt 阻塞 时 退出 阻塞状态 threadsleep 主 线程 休眠 秒 以便 观察 线程 m 的 中断 情况 notify 和 notifyall 有 什么区别 notify 可能会 导致 死锁 而 notifyall 则 不会 任何时候 只有 一个 线程 可以获得 锁 也就是说 只有 一个 线程 可以 运行 synchronized 中 的 代码 使用 notifyall 可以 唤醒 所有 处于 wait 状态 的 线程 使其 重新 进入 锁 的 争夺 队列 中 而 notify 只能 唤醒 一个 wait 应 配合 while 循环 使用 不应 使用 if 务必 在 wait 调用 前后 都 检查 条件 如果 不满足 必须 调用 notify 唤醒 另外 的 线程 来 处理 自己 继续 wait 直至 条件 满足 再 往下 执行 notify 是 对 notifyall 的 一个 优化 但它 有 很 精确 的 应用 场景 并且 要求 正确 使用 不然 可能 导致 死锁 正确 的 场景 应该是 waitset 中 等待 的 是 相同 的 条件 唤醒 任一 个 都能 正确处理 接下来 的 事项 如果 唤醒 的 线程 无法 正确处理 务必 确保 继续 notify 下一个 线程 并且 自身 需要 重新 回到 waitset 中 sleep 和 wait 有 什么区别 对于 sleep 方法 我们 首先要 知道该 方法 是 属于 thread 类 中 的 而 wait 方法 则是 属于 object 类 中 的 sleep 方法 导致 了 程序 暂停 执行 指定 的 时间 让出 cpu 该 其他 线程 但是 他 的 监控 状态 依然 保持者 当 指定 的 时间 到了 又会 自动 恢复 运行 状态 在 调用 sleep 方法 的 过程中 线程 不会 释放 对象 锁 当 调用 wait 方法 的 时候 线程 会 放弃 对象 锁 进入 等待 此 对象 的 等待 锁定 池 只有 针 对此 对象 调用 notify 方法 后 本 线程 才 进入 对象 锁定 池 准备 获取 对象 锁 进入 运行 状态 volatile 是什么 可以 保证 有序性 吗 一旦 一个 共享 变量 类 的 成员 变量 类 的 静态 成员 变量 被 volatile 修饰 之后 那么 就 具备 了 两层 语义 保证 了 不同 线程 对 这个 变量 进行 操作 时 的 可 见性 即 一个 线程 修 改了 某个 变量 的 值 这 新 值 对 其他 线程 来 说是 立即 可见 的 volatile 关键字 会 强制 将 修改 的 值 立即 写入 主存 禁止 进行 指令 重 排序 volatile 不是 原子 性 操作 什么 叫 保证 部分 有序性 当 程序 执行 到 volatile 变量 的 读 操作 或者 写 操作 时 在其 前面 的 操作 的 更改 肯定 全部 已经 进行 且 结果 已经 对 后面 的 操作 可见 在其 后面 的 操作 肯定 还没有 进行 x 语句 y 语句 flagtrue 语句 x 语句 y 语句 由于 ag 变量 为 volatile 变量 那么 在 进行 指令 重 排序 的 过程 的 时候 不 会将 语句 放到 语句 语句 前面 也 不 会讲 语句 放到 语句 语句 后面 但是 要注意 语句 和 语句 的 顺序 语句 和 语句 的 顺序 是 不作 任何 保证 的 使用 volatile 一般 用于 状态 标记 量 和 单 例 模式 的 双 检 锁 thread 类 中 的 start 和 run 方法 有 什么区别 start 方法 被 用来 启动 新创建 的 线程 而且 start 内部 调 用了 run 方法 这 和 直接 调用 run 方法 的 效果 不一样 当你 调用 run 方法 的 时候 只 会是在 原来 的 线程 中 调用 没有 新 的 线程 启动 start 方法 才会 启动 新 线程 为什么 waitnotify 和 notifyall 这些 方法 不在 thread 类 里面 明显 的 原因是 java 提供 的 锁 是 对象 级 的 而 不是 线程 级 的 每个 对象 都有 锁 通过 线程 获得 如果 线程 需要 等待 某些 锁 那么 调用 对象 中 的 wait 方法 就有 意义 了 如果 wait 方法 定义 在 thread 类 中 线程 正在 等待 的 是 哪个 锁 就不 明显 了 简单 的 说 由于 waitnotify 和 notifyall 都是 锁 级别 的 操作 所以 把 他们 定义 在 object 类 中 因为 锁 属于 对象 为什么 wait 和 notify 方法 要在 同步 块 中 调用 只有 在 调用 线程 拥有 某个 对象 的 独占 锁 时 才能够 调用 该 对象 的 wait notify 和 notifyall 方法 如果 你 不 这么 做你 的 代码 会 抛出 异常 还有 一个 原因 是为了 避免 wait 和 notify 之间 产生 竞 态 条件 wait 方法 强制 当前 线程 释放 对象 锁 这 意味着 在 调用 某 对象 的 wait 方法 之前 当前 线程 必须 已经 获 得该 对象 的 锁 因此 线程 必 须在 某个 对象 的 同步 方法 或 同步 代码 块 中 才能 调用 该 对象 的 wait 方法 在 调用 对象 的 notify 和 notifyall 方法 之前 调用 线程 必须 已经 得到 该 对象 的 锁 因此 必 须在 某个 对象 的 同步 方法 或 同步 代码 块 中 才能 调用 该 对象 的 notify 或 notifyall 方法 调用 wait 方法 的 原因 通常是 调用 线程 希望 某个 特殊 的 状态 或 变量 被 设置 之后 再 继续 执行 调用 notify 或 notifyall 方法 的 原因 通常是 调用 线程 希望 告诉 其他 等待中 的 线程 特殊 状态 已经 被 设置 这个 状态 作为 线程 间 通信 的 通道 它 必须 是 一个 可变 的 共享 状态 或 变量 java 中 interrupted 和 isinterruptedd 方法 的 区别 interrupted 和 isinterrupted 的 主要 区 别是 前者 会将 中断 状态 清除 而 后者 不会 java 多线程 的 中断 机制 是 用 内部 标识 来 实现 的 调用 threadinterrupt 来 中断 一个 线程 就会 设置 中断 标识 为 true 当中 断 线程 调用 静态 方法 来 检查 中断 状态 时 中断 状态 会被 清零 而非 静态 方法 isinterrupted 用来 查询 其它 线程 的 中断 状态 且不 会 改变 中断 状态 标识 简单 的 说 就是 任何 抛出 异常 的 方法 都 会将 中断 状态 清零 无论如何 一个 线程 的 中断 状态 有 有 可能 被 其它 线程 调用 中断 来 改变 java 中 synchronized 和 reentrantlock 有 什么 不同 相似 点 这两种 同步 方式 有 很多 相似之处 它们 都是 加锁 方式 同步 而且 都是 阻塞 式 的 同步 也就是说 当 如果 一个 线程 获得了 对象 锁 进 入了 同步 块 其他 访问 该 同步 块 的 线程 都必须 阻 塞在 同步 块 外面 等待 而 进行 线程 阻塞 和 唤醒 的 代价 是 比 较高 的 区别 这两种 方式 最大 区别 就是 对于 synchronized 来说 它是 java 语言 的 关键字 是 原生 语法 层面 的 互斥 需要 jvm 实现 而 reentrantlock 它是 jdk 之后 提供 的 api 层面 的 互斥 锁 需要 lock 和 unlock 方法 配合 trynally 语句 块 来 完成 synchronized 进过 编译 会在 同步 块 的 前后 分别 形成 monitorenter 和 monitorexit 这个 两个 字节 码 指令 在 执行 monitorenter 指令 时 首先要 尝试 获取 对象 锁 如果 这个 对象 没被 锁定 或者 当前 线程 已经 拥有 了 那个 对象 锁 把 锁 的 计算器 加 相应 的 在 执行 monitorexit 指令 时 会将 锁 计算器 就 减 当 计算器 为时 锁 就被 释放 了 如果 获取 对象 锁 失败 那 当前 线程 就要 阻塞 直到 对象 锁 被 另一个 线程 释放 为止 由于 reentrantlock 是 包下 提供 的 一套 互斥 锁 相比 类 提供 了 一些 高级 功能 主要有 以下 项 等待 可 中断 持有 锁 的 线程 长期 不 释放 的 时候 正在 等待 的 线程 可以 选择 放弃 等待 这 相当于 synchronized 来说 可以 避免 出现 死锁 的 情况 公平 锁 多个 线程 等待 同一个 锁 时 必须 按照 申请 锁 的 时间 顺序 获得 锁 synchronized 锁 非 公平 锁 reentrantlock 默认 的 构造 函数 是 创建 的 非 公平 锁 可以 通过 参数 true 设为 公平 锁 但 公平 锁 表现 的 性能 不是 很好 锁 绑定 多个 条件 一个 reentrantlock 对象 可以 同时 绑定 对 个 对象 有 三个 线程 ttt 如何 保证 顺序 执 行在 多线程 中有 多种 方法 让 线程 按 特定 顺序 执行 你 可以用 线程 类 的 join 方法 在 一个 线程 中 启动 另一个 线程 另外 一个 线程 完成 该 线程 继续 执行 为了 确保 三个 线程 的 顺序 你 应该 先 启动 最后 一个 t 调用 tt 调用 t 这样 t 就会 先 完成 而 t 最后 完成 实际上 先 启动 三个 线程 中 哪一个 都行 因为 在 每个 线程 的 run 方法 中用 join 方法 限定 了 三个 线程 的 执行 顺序 现在 有 ttt 三个 线程 你 怎样 保证 t 在 t 执行 完 后 执行 t 在 t 执行 完 后 执行 stringargs newrunnable t try 引用 t 线程 等待 t 线程 执行 完 tjoin catch t newrunnable try 引用 t 线程 等待 t 线程 执行 完 tjoin catch t tstart 这里 三个 线程 的 启动 顺序 可以 任意 大家 可以 试 下 tstart tstart synchronizedmap 和 有 什么区别 synchronizedmap 和 hashtable 一样 实现 上 在 调用 map 所有 方法 时 都对 整个 map 进行 同步 而 的 实现 却更 加 精细 它对 map 中 的 所有 桶 加了 锁 所以 只要 有 一个 线程 访问 map 其他 线程 就 无法 进入 map 而 如果 一个 线程 在 访问 某个 桶 时 其他 线程 仍然 可 以对 map 执行 某些 操作 所以 在 性能 以及 安全性 方面 明显 比 更加 有 优势 同时 同步操作 精确 控制 到 桶 这样 即使 在 遍历 map 时 如果 其他 线程 试图 对 map 进行 数据 修改 也 不会 抛出 什么 是 线程 安全 线程 安全 就是说 多线程 访问 同一 代码 不会 产生 不确定 的 结 果在 多线程 环境 中 当 各 线程 不 共享 数据 的 时候 即 都是 私有 private 成员 那么 一 定是 线程 安全 的 但 这种 情况 并不 多见 在 多数 情况下 需要 共享 数据 这时 就需要 进行 适当 的 同步 控制 了 线程 安全 一般 都 涉及到 synchronized 就是 一段 代码 同时 只能 有 一个 线程 来 操作 不然 中间 过程 可能会 产生 不可 预制 的 结果 如果 你 的 代码 所在 的 进程 中有 多个 线程 在 同时 运行 而 这些 线程 可能会 同时 运行 这段 代码 如果 每次 运行 的 arraylist 不是 线程 安全 的 thread 类 中 的 yield 方法 有 什么 作用 yield 方法 可以 暂停 当前 正在 执行 的 线程 对象 让 其它 有 相同 优先级 的 线程 执行 它是 一个 静态 方法 而且 只 保证 当前 线程 放弃 cpu 占用 而 不能 保证 使 其它 线程 一 定能 占用 cpu 执行 yield 的 线程 有 可能在 进入到 暂停 状态 后 马上 又被 执行 java 线程 池中 submit 和 execute 方法 有 什么区别 两个 方法 都可以 向 线程 池 提交 任务 execute 方法 的 返回 类型 是 void 它 定义 在 executor 接 口中 而 submit 方法 可以 返回 持有 计算结果 的 future 对象 它 定义 在 executorservice 接 口中 它 扩展 了 executor 接口 其它 线程 池 类像 和 都有 这些 方法 说一说 自己 对于 synchronized 关键字 的 了解 synchronized 关键字 解决 的 是 多个 线程 之间 访问 资源 的 同步 性 synchronized 关键字 可以 保证 被 它 修饰 的 方法 或者 代码 块 在 任意 时刻 只能 有 一个 线程 执行 另 外在 java 早期 版本 中 synchronized 属于 重量级 锁 效率 低下 因为 监视器 锁 monitor 是 依赖于 底层 的 操作系统 的 mutexlock 来 实现 的 java 的 线程 是 映 射到 操作系统 的 原生 线程 之上 的 如果 要 挂起 或者 唤醒 一个 线程 都 需要 操作系统 帮忙 完成 而 操作系统 实现 线程 之间 的 切换 时 需 要从 用户 态 转 换到 内核 态 这个 状态 之间 的 转换 需要 相对 比 较长 的 时间 时间 成本 相对 较高 这 也是 为什么 早期 的 synchronized 效率 低 的 原因 庆幸 的 是 在 java 之后 java 官方 对 从 jvm 层 面对 synchronized 较大 优化 所以 现在 的 synchronized 锁 效率 也 优化 得很 不 错了 jdk 对 锁 的 实现 引 入了 大量 的 优化 如 自旋 锁 适应性 自旋 锁 锁 消除 锁 粗 化 偏向 锁 轻量级 锁 等 技术 来 减少 锁 操作 的 开销 说说 自己 是 怎么 使用 synchronized 关键字 在 项目 中用 到 了吗 synchronized 关键字 最主要 的 三种 使用 方式 修饰 实例 方法 作用于 当前 对象 实例 加锁 进入 同步 代码 前 要 获得 当前 对象 实例 的 锁 修饰 静态 方法 也 就是 给 当前 类 加锁 会 作用于 类 的 所有 对象 实例 因为 静态 成员 不属于 任何 一个 实例 对 象是 类 成员 static 表明 这是 该类 的 一个 静态 资源 不管 new 了 多少个 对象 只有 一份 所以 如果 一个 线程 a 调用 一个 实例 对象 的 非 静态 synchronized 方法 而 线程 b 需要 调用 这个 实例 对象 所属 类 的 静态 synchronized 方法 是 允许 的 不会 发生 互斥 现象 因为 访问 静态 synchronized 方法 占用 的 锁 是 当前 类 的 锁 而 访问 非 静态 synchronized 方法 占用 的 锁 是 当前 实例 对象 锁 修饰 代码 块 指定 加锁 对象 对 给定 对象 加锁 进入 同步 代码 库 前 要 获得 给定 对象 的 锁 总结 synchronized 关键字 加到 static 静态 方法 和 synchronized class 代码 块 上 都是 是 给 class 类 上锁 synchronized 关键字 加到 实例 方法 上 是 给 对象 实例 上锁 尽量 不要 使用 synchronized stringa 因为 jvm 中 字符串 常量 池 具有 缓存 功能 什么 是 线程 安全 vector 是 一个 线程 安全类 吗 如果 你 的 代码 所在 的 进程 中有 多个 线程 在 同时 运行 而 这些 线程 可能会 同时 运行 这段 代码 如果 每次 运行 结果 和 单线程 运行 的 结果是 一样 的 而且 其他 的 变量 的 值 也 和 预期 的 是 一样 的 就是 线程 安全 的 volatile 关键字 的 作用 一旦 一个 共享 变量 类 的 成员 变量 类 的 静态 成员 变量 被 volatile 修饰 之后 那么 就 具备 了 两层 语义 保证 了 不同 线程 对 这个 变量 进行 操作 时 的 可 见性 即 一个 线程 修 改了 某个 变量 的 值 这 新 值 对 其他 线程 来 说是 立即 可见 的 禁止 进行 指令 重 排序 volatile 本质 是 在 告诉 jvm 当前 变量 在 寄存器 工作 内存 中 的 值 是 不确定 的 需 要从 主存 中 读取 synchronized 则是 锁定 当前 变量 只有 当前 线程 可以 访问 该 变量 其他 线程 被 阻塞住 volatile 仅能 使 用在 变量 级别 synchronized 则可 以使 用在 变量 方法 和 类 级别 的 volatile 仅能 实现 变量 的 修改 可 见性 并不能 保证 原子 性 synchronized 则 可以 保证 变量 的 修改 可 见性 和 原子 性 volatile 不会 造成 线程 的 阻塞 synchronized 可能会 造成 线程 的 阻塞 volatile 标记 的 变量 不 会被 编译器 优化 synchronized 标记 的 变量 可以 被 编译器 优化 常用 的 线程 池 有 哪些 创建 一个 单线程 的 线程 池 此 线程 池 保证 所有 任务 的 执行 顺序 按照 任务 的 提交 顺序 执行 创建 固定 大小 的 线程 池 每次 提交 一个 任务 就 创建 一个 线程 直到 线程 达到 线程 池 的 最大 大小 创建 一个 可 缓存 的 线程 池 此 线程 池 不会 对 线程 池 大小 做 限制 线程 池 大小 完全 依赖于 操作系统 或者说 jvm 能够 创建 的 最大 线程 大小 创建 一个 大小 无限 的 线程 池 此 线程 池 支持 定时 以及 周期性 执行任务 的 需求 创建 一个 单线程 的 线程 池 此 线程 池 支持 定时 以及 周期性 执行任务 的 需求 简述 一下 你 对 线程 池 的 理解 如果 问 到了 这样 的 问题 可以 展开 的 说 一下 线程 池 如 何用 线程 池 的 好处 线程 池 的 启动 策略 合理 利用 线程 池 能够 带来 三个 好处 降低 资源 消耗 通过 重复 利用 已 创建 的 线程 降低 线程 创 建和 销毁 造成 的 消耗 提高 响应速度 当 任务 到达 时 任务 可以 不需要 等到 线程 创建 就能 立即 执行 提高 线程 的 可管理性 线程 是 稀缺资源 如果 无限制 的 创建 不仅 会 消耗 系统资源 还会 降低 系统 的 稳定性 使用 线程 池 可以 进行 统一 的 分 配调 优 和 监控 java 程序 是 如何 执行 的 我们 日常 的 工作 中都 使用 开发工具 intellijidea 或 eclipse 等 可以 很 方便 的 调试程序 或者是 通过 打包 工具 把 项目 打 包成 jar 包 或者 war 包 放入 tomcat 等 web 容器 中就 可以 正常 运 行了 先把 java 代码 编译成 字节 码 也 就是 把 java 类型 的 文件 编译成 class 类型 的 文件 这个 过程 的 大致 执行 流程 java 源代码 gt 词法 分析器 gt 语法 分析器 gt 语义 分析器 gt 字符 码 生成器 gt 最终 生成 字节 码 其中 任何 一个 节点 执行 失败 就会 造成 编译 失败 把 class 文件 放置 到 java 虚拟机 这个 虚拟机 通常 指的是 oracle 官方 自带 的 hotspotjvmjava 虚拟机 使用 类 加载 器 classloader 装载 class 文件 类 加载 完成 之 后会 进行 字节 码 效验 字节 码 效验 通过 之后 jvm 解释 器 会把 字节 码 翻译成 机器码 交由 操作系统 执行 但 不是 所有 代码 都是 解释 执行 的 jvm 对此 做了 优化 比 如以 hotspot 虚拟机 来说 它本身 提供 了 jitjustintime 也 就是 我们 通常 所说 的 动态 编译器 它 能够 在运 行时 将 热点 代码 编 译为 机器码 这个 时候 字节 码 就 变 成了 编译 执行 java 程序 执行 流程图 如下 最后 欢迎 关注 公众 号 程序员 追风 领取 一线 大厂 java 面试题 总结 各 知识点 学习 思维 导 一份 页 pdf 文档 的 java 核心 知识点 总结 这些 资料 的 内容 都是 面试时 面试官 必 问 的 知识点 篇章 包括 了 很多 知识点 其中 包括 了 有 基础知识 java 集合 jvm 多线程 并发 spring 原理 微 服务 netty 与 rpckafka 日记 设计 模式 java 算法 数据库 zookeeper 分布式 缓存 数据结构 等等 