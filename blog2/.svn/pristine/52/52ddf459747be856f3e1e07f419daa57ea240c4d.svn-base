多线程 面试题 3 多线程 面试题 synchronized 关键字 加在 静态 方法 和 实例 方法 的 区别 修饰 静态 方法 是 对 类 进行 加锁 如果 该类 中有 methoda 和 methodb 都是 被 synchronized 修饰 的 静态 方法 此时 有 两个 线程 tt 分别 调用 methoda 和 methodb 则 t 会 阻塞 等待 直到 t 执行 完成 之后 才能 执行 修饰 实例 方法 时 是 对 实例 进行 加锁 锁 的 是 实例 对象 的 对 象头 如果 调用 同一个 对象 的 两个 不同 的 被 synchronized 修饰 的 实例 方法 时 看到 的 效果 和 上面 的 一样 如果 调用 不同 对象 的 两个 不同 的 被 synchronized 修饰 的 实例 方法 时 则 不会 阻塞 countdownlatch 的 用法 两种 用法 让 主 线程 await 业务 线程 进行 业务 处理 处理 完成 时 调用 countdownlatch 实例 化 的 时候 需要 根据 业务 去 选择 countdownlatch 的 count 让 业务 线程 await 主 线程 处 理完 数据 之后 进行 此时 业务 线程 被 唤醒 然 后去 主 线程 拿 数据 或者 执行 自己 的 业务 逻辑 描述 一下 锁 的 四种 状态 及 升级 过程 详解 reentrantlock 原理 底层 原理 详解 cpu 缓存 一致性 详解 