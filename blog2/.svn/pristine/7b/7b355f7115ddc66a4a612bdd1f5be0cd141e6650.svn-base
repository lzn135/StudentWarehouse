java 中 死锁 之 代码 演示 和 检测 简介 本文 将 通过 java 代码 演示 一个 死锁 程序 并用 jdk 自带 的 工具 jstack 工具 来 验证 下 是否 真正 的 有 死锁 发生 一 什么 是 死锁 两个 或 两个 以上 的 线程 互相 持有 对方 需要 的 资源 导致 这些 线程 一直 处于 等待 waiting 状态 二 死锁 的 代码 演示 本例 演示 两个 线程 互相 竞争 对方 的 对象 锁 造成 的 死锁 stringargs deadlock deadlock tstart tstart 当前 是 线程 condition if condition synchronized object 线程 得到 object 锁 trythreadsleep catch 线程 卡在 下一 行 代码 synchronized object 打印 出 此行 表示 线程 同时 获得 两把 锁 线程 执行 完毕 if condition synchronized object 线程 得到 object 锁 trythreadsleep catch 线程 卡在 下一 行 代码 synchronized object 打印 出 此行 表示 线程 同时 获得 两把 锁 线程 执行 完毕 运行 结果 当前 是 线程 当前 是 线程 线程 得到 object 锁 线程 得到 object 锁 线程 卡在 下一 行 代码 线程 卡在 下一 行 代码 运行 结果 分析 线程 持有 了 object 的 锁 线程 持有 了 object 的 锁 然后 线程 去 竞争 object 锁 线程 去 竞争 object 锁 由于 线程 并没有 释放 object 锁 线程 也 并没有 释放 object 锁 所以会 造成 死锁 三 验证 是否 真正 死 锁在 命令行 中 输入 jps 查到 我们 代码 程序 的 进程 号为 然后 在 命令行 再 输入 jstackl 分析 下 程序 状态 发现 程序 中 出现 了 死锁 现象 总结 明白 了 死锁 发生 的 机制 我们 可以 想办法 避免 死锁 发生 第一 种方法 是 注意 加锁 顺序 在上 面的 代码 实例 中 我们 只 要在 两个 线程 中 对 锁 的 竞争 顺序 保持一致 比如 两个 线程 都是 先 竞争 object 锁 再 竞争 object 锁 那 死锁 就不会 出现 了 第二种 避免 死锁 的 方式 是 设置 超时 时间 如果 超过 一定 时间 自动 释放 锁在 程序 运行时 我们 可以 通过 jstack 工具 查看 程序 运行 状态 是否 有 死锁 