seata tc 启动 流程 分析 戳 蓝字 topcoder 关注 我们 哦 编者注 seata 是 一款 阿里 开源 的 分布式 事务 解决方案 致力于 提供 高性能 和 简单 易用 的 分布式 事务 服务 seata 将为 用户 提供 了 attccsaga 和 xa 事务 模式 为 用户 打造 一站式 的 分布式 解决方案 github 地址 分析 seatatc 启动 流程 之前 首先 看下 分布式 事务 的 核心 要点 事务 的 持久 化 事务 所处 的 各种 状态 事务 参与 方 的 各种 状态 都 需要 持久 化 当 实例 宕 机时 才能 基于 持久 化 的 数据 对 事务 回 滚 或 提交 实现 最终 一致性 定时 对 超时 未完成 事务 的 处理 继续 尝试 提交 或 回 滚 即 通过 重试 机制 实现 事务 的 最终 一致性 分布式 事务 的 跨 服务 实例 传播 当 分布式 事务 跨 多个 实例 时 需要 实现 事务 的 传播 一般 需要 适配 不同 的 rpc 框架 事务 的 隔离 级别 大多数 分布式 事务 为了 性能 默认 的 隔离 级 别是 读 未 提交 幂 等 性 对于 xa 或者 seata 的 at 这样 的 分布式 事务 来说 都 已经 默认 实现 了 幂 等 性 而 tccsaga 这种 接口 级别 实现 的 分布式 事务 都还 需要 业务 开发者 自己 实现 幂 等 性 tcserver 端 启动 流程 如下 启动 类 seataserver 启动 方法 默认 启动 端口 方法 主 要是 解析 并 设置 一些 配置 初始化 几个 线程 池 启动 和 netty 服务 等 源码 如下 stringargs args port 消息 处理 线程 池 netty 接 收到 消息 后传 递给 该 线程 进行 处理 workingthreads 默认 的 事务 协调 器 attccxasaga 等 coordinatorinit 初始化 几个 线程 池 commit 重试 rollback 重试 等 todo 待 分析 coordinator adddisposable coordinator adddisposable xidsetipaddress xidsetport 启动 服务 systemexit sessionholder 负责 session 的 持久 化 一个 session 对象 对应 一个 事务 事务 分为 两种 全局 事务 globalsession 和 分支 事务 支持 filedbredis 这 几种 持久 化 方式 其中 db 支持 集群 模式 推荐 使用 dbsessionholder 中最 主要 的 四个 字段 如下 用于 获取 所有 的 setssion 以及 session 的 创建 更新 删除 等 用于 获取 更新 所有 的 异步 commit 的 用于 获取 更新 所有 需要 重试 commit 的 用于 获取 更新 所有 需要 重试 rollback 的 目前 tc 这块 关于 ha 的 特性 这块 支持 不太 多 不过 可以 将 sessionstore 设置 为 db 来 支持 tc 的 故障 转移 毕竟 session 数据 还在 是 事务 协调 器 的 核心 如 开启 提 交回 滚 全局 事务 注册 提 交回 滚 分支 事务 都是 由 负责 协调 处理 的 通过 rpcserver 与 远程 的 tmrm 通信 来 实现 分支 事务 的 提 交回 滚 等 netty 初始化 netty 初始化 从 方法 开始 首 先会 注册 各种 处理器 然后 开始 标准 的 netty 启动 过程 启动 bossgroup 和 wrokergroup 设置 编解码器 和 netty 初始化 superinit publicvoidstart localaddress listenport childhandler socketchannelch 心跳 chpipeline addlast addlast addlast if listenport sync register xidgetipaddress xidgetport initializedset true futurechannel closefuture sync netty 注册 各种 处理器 也 就是 对应 的 业务 处理器 这些 处理器 有些 是 在 业务 线程 池中 执行 的 这里 的 业务 线程 池 也 就是 main 方法 中 创建 的 线程 池 处理器 类型 有 tc 注册 rm 注册 全局 事务 操作 心跳 等 类型 thisgethandler gethandler getfutures this this this 注意 如果 入 参 executor 为 空 的话 就 会在 nettyworker 线程 中 来 执行 之后 tcserver 端 就 开始 工 作了 接收 tmrm 的 请求 然后 进行 处理 实际 的 处理 大都是 交给 不同 的 处理器 来 完成 的当 处理器 完成 之后 再 通过 nettychannel 回 写 响应 结果 给 客户端 这 就是 大致 的 通信 流程 推荐 阅读 seataat 模式 流程 seata 事务 提交 流程 seata 是什么 mysqlupdate 语句 和 原 数据 一样 会 更新 么 