原理 浅析 戳 蓝字 topcoder 关注 我们 哦 java 新增 了 提供 对 异步 计算 的 支持 可以 通过 回 调 的 方式 处理 计算结果 类 实现 了 completionstage 和 future 接口 所以 还 可以 像 之前 使用 future 那样 使用 尽管 已 不再 推荐 这样 用了 试想 下 这个 场景 要 执行 一个 任务 逻辑 交给 另一个 线程 处理 并 针对 任务 结果 转换 最后 执行 打印 操作 那么 该 如 完成 呢 一种 是 使用 futureget 获取 任务 结果 并 执行 转换 逻辑 最后 执行 打印 操作 有没有 像 stream 那样 的 处理方式 呢 借助 的话 实现 代码 如下 gt thenapply sgtslength integer 从 上述 的 示例 代码 我们 可以 大致 分析 下 的 执行 流程 首先 会 异步 执行 supply 任 务当 supply 任务 执行 结束 时会 自动 执行 对应 的 计算 slength 逻辑 这里 问题 来了 当前 调用 thenapply 方法 的 线程 这里是 main 线程 会对 提交 function 对应 的 是 计算 slength 逻辑 那么 到底是 哪个 线程 执行 的 计算 slength 逻辑 呢 由于 supply 任务 是 由 其他 线程 来 执行 的 这里 对应 的 是 forkjoin 线程 当 main 线程 调用 thenapply 方法 时 不能 确定 supply 任务 是否 执行 完毕 的 因此 这时 就要 分种 情况 如果 supply 任务 已经 执行 完毕 那么 就需要 当前 main 线程 来 执行 slength 逻辑 如果 supply 任务 还未 执行 完毕 显然 这时候 main 线程 需 要将 function 记 录到 中 这样 当 forkjoin 线程 执行 完 supply 任务 时 可以 执行 slength 逻辑 这时 就是 forkjoin 线程 来 执行 的 对于 上述 的 两种 情况 测试 代码 如下 thenapply rgtr whencomplete re format r return thenapply rgtr whencomplete re format r stringmsg getname msg 输出 结果 如下 最后 到了 whencomplete 的 逻辑 其实 仔细 思考 下 不管是 thenapply 还是 whencomplete 都是 接下来 要 执行 的 动作 那么 它们 的 执行 逻辑 应该是 类似 的 这里 不再 赘述 在 上述 分析 完毕 后 我们 来 实际 看下 源码 来 一探 究竟 其 执行 流程 为了 方便 查看 源码 debug 使用 如下 示例 代码 nextint ms format msg returnmsg thenapply strings format returnslength whencomplete format dones 输出 结果 为 下面 就 按照 示例 代码 照 提交 supplyasync 提交 thenapply 执行 whencomplete 流程 来 进行 分析 注意 的 方法 大都是 返回 新 的 对象 提交 supplyasync 时 如果 外部 未 传递 线程 池 那么 就会 使用 默认 的 forkjoin 线程 池 然后 线程 池中 提交 asyncsupply 任务 asyncsupply 类 继承 forkjointask 并 实现 了 runnable 源码 如下 eexecute df ddep nullampamp ffn null depnullfnnullif dresultnull try 执行 supplier 方法 并 设置 fget catch throwableex 异常 ex 正常 执行 执行 回 调 dpostcomplete 注意 中 设置 结果 和 是否 执行 回 调 是 基于 cas 思路 来 做的 这里 正常 result 和 异常 result 没什么 太多 好说 的 重点 关注 下 postcomplete 回 调 这里 的 回 调 也 就是 执行 thenapply 或者 whencomplete 添 加上 的 执行 回 调 hfstack null fthisampamp h fthis stack null fcasstack hthnext 提取 stack 第一个 元素 后 cas 重置 stackif tnull if fthis f 不等于 this 表示 htryfire 返 回了 另一个 fpushstack h 执行 回 调 f dhtryfire nested nullthisd 注意 stack 属性 它是 一个 使 用上 是 栈 思路 的 属性 但 实际 数据结构 是 链表 只不过 使 用上 是 头 插入 头 读取 的 执行 tryfire 就是 执行 对应 thenapply 或者 whencomplete 添 加上 的 执行 回 调 逻辑 了 回到 最初 的 示例 代码 thenapply 或者 whencomplete 都 往 中 提交 的 是什么 completion 呢 从 源码 中 可以 得知 thenapply 最后 提交 的 是 最后 提交 的 是 uniwhencomplete 二者 的 动作 都是 将 各自 对应 的 completion 提 交到 当前 的 中 其中 提交 uniwhencomplete 的 源码 如下 if thisfnull edthisf push c ctryfire sync returnd 注意 这里 的 ctryfire sync 内 部会 判断 上一个 字段 是否 已 存在 结果 如果 不存 在其 内部 不会 做什么 逻辑 的 从 上图 结合 thenapply 或者 whencomplete 提交 的 completion 可以 看出 每种 类型 方法 都 对应 了 一种 completion 来 处理 多个 completion 会被 存 放到 数据结构 中 这样 等到 执行 回 调 时 就能 按照 顺序 执 行了 都会 对应 有 一个 stack 数据结构 也 就说 针对 同一个 对象 添加 多个 completion 执行 completion 回 调 是 按照 其 逆序 进行 执行 的 针对 多个 的 添加 completion 是 按照 的 添加 次序 来 顺序 执行 的 对应 的 测试 代码 如下 小结 co 的 多个 操作 也 就是 多个 之间 如果 上一个 未完成 则 会将 当前 动作 添加到 上一个 的 stack 数据结构 中 在 任务 执行 完毕 之后 回 执行 对应 stack 中 的 completion 回 调 方法 每个 操作 基本上 都对 应有 completion 处理 类 看完 文章 示例 代码 是不是 还 不太 清楚 多个 之间 的 执行 流程 呢 说实话 笔者 第一次 看 的 时候 也是 这样 的 下面 我们 换个 例子 并 给出 图示 来看 helloworldf sleep returnresultf r sleep returnf r sleep returnf r sleep returnf r sleep returnf r sleep returnf 上面 代码 对应 的 及其 completion 关系 如 下图 结合 上图 和 postcomplete 流程 可以 看出 执行 回 调 的 顺序 是 如果 这里 没 看懂 可以 回 过头 再 看下 postcomplete 方法 的 源码 推荐 阅读 应用 实践 java 线程 池 实现 原理 深入 理解 java 线程 池 jmmjava 内存 模型 happensbefore 那些 事儿 为什么 说 locksupport 是 java 并发 的 基石 