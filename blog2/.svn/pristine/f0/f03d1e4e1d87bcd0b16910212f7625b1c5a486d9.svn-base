android jetpack 高手 日志 lifecycle 从 入门 到 精通 背景 androidjetpack 是 一个 由 多个 库 组成 的 套件 可 帮助 开发者 遵循 最佳 做法 减少 样板 代码 并 编写 可在 各种 android 版本 和 设备 中 一致 运行 的 代码 让 开发者 精力 集中 编写 重要 的 代码 也就是说 google 开 发了 一套 通用 的 库 让我们 使用 帮助 开发者 高效 的 开发 应用 的 工具 集 详细 内容 可以 参考 这里 介绍 lifecycle 是 androidjetpack 的 一部分 是 生命周期 感知 型 组件 可执行 操作 来 响应 另一个 组件 activity 和 fragment 的 生命周期 状态 的 变化 lifecycle 是 一个 类 用于 存储 有关 组件 如 activity 或 fragment 的 生命周期 状态 的 信息 并 允许 其他 对象 观察 此 状态 它是 livedata 和 viewmodel 的 基础 如果 你想 更 深入 的 了解 androidjetpack 的 其他 组件 你 应该 从 它 学起 为什么 我们 需要 它 举个 例子 假设 我们 有 一个 在 屏幕 上 显示 设备 位置 的 activity 常见 的 实现 可能 如下 所示 location gtunit funstart this superonstart superonstop 虽然 这个 例子 看起来 没有 太大 的 问题 但是在 实际 应用 中最 终会 有 太多 管理 界面 和 其他 组件 的 调 用以 响应 生命周期 的 当前 状态 比如 多个 组件 会在 生命周期 方法 onstart 和 onstop 中 放置 大量 代码 不利于 维护 此外 无法 保证 组件 会在 activity 或 fragment 停止 之前 启动 在 我们 需要 执行 长时间 运行 的 操作 如 onstart 中 的 某种 配置 检查 时 尤其 如此 这 可能会 导致 出现 一种 竞 态 条件 在 这种 条件下 onstop 方法 会在 onstart 之前 结束 这 使得 组件 留存 的 时间比 所需 的 时间 要 长 this superonstart 如果在 activitystop 后 调用 此 回 调 该 怎么办 通常 我们 的 处理 是 注 销回 调 要 手动 处理 使用 lifecycle 就 自动 帮助 我们 处 理了 if result superonstop 软件包 提供 的 类 和 接口 可 帮 助您 以 弹性 和 隔离 的 方式 解决 这些 问题 基础 使用 导入 依赖 使用 然后 我们 来 看看 怎么 解决 上面 的 问题 我们 可以 通过 添加 注解 来 监控 组件 的 生命周期 状态 您 可以 通过 调用 lifecycle 类 的 addobserver 方法 并 传递 观察者 的 实例 来 添加 观察者 如 以下 示例 中 所示 addobserver myobserver lifecycleowner 是 单一 方法 接口 表示 类 具有 lifecycle 它 具有 一种 方法 即 getlifecycle 该 方法 必 须由 类 实现 此 接口 从 各个 类 如 fragment 和 抽象化 lifecycle 的 所有权 并 允许 编写 与 这些 类 搭配 使用 的 组件 任何 自定义 应用 类 均可 实现 lifecycleowner 接口 实现 的 组件 可 与 实现 lifecycleowner 的 组件 完美 配合 因为 所有者 可以 提供 生命周期 而 观察者 可以 注册 以 观察 生命周期 thislifecycle result 对于 未知 跟踪 实例 我们 可以 让 类 实现 然后 在 oncreate 方法 中 实现 activity 的 lifecycle 对 其 进行 初始化 然后 配合 注解 这 意味着 对 生命周期 状态 的 变化 做出 响应 的 逻辑 会在 而 不是 在 activity 中 进行 声明 让 各个 组件 存储 自己 的 逻辑 可使 activity 和 fragment 逻辑 更 易于 管理 同时 还要 注意 的 是 如果 lifecycle 现在 未 处于 良好 的 状态 则应 避免 调用 某些 回 调 例如 如果 回 调在 activity 状态 保存 后 运行 fragment 事务 就会 触发 崩溃 因此 我们 绝不能 调用 该回 调为 简化 此 使用 场景 lifecycle 类 允许 其他 对象 查询 当前 状态 对 应到 的 做法 如下 location gtunit funstart if enabled enabledtrueif funstop 对 于此 实现 类 可以 完全 感知 生命周期 如果 我们 需 要从 另一个 activity 或 fragment 使用 只需 对 其 进行 初始化 所有 设置 和 拆解 操作 都由 类 本身 管理 如果您 尝试 管理 整个 应用 进程 的 生命周期 请参阅 生命周期 通常 我们 判断 在 应用 是不是 处于 前 后台 的 做法 是 注册 一个 callback 然后 在 callback 中 利用 一个 全局变量 做 计数 在 中 计数 加在 方法 中 计数 减 从而 判断 前 后台 切换 而 使用 可以 直接 获取 应用 前 后台 切换 状态 记得 先 引入 依赖 使用 方式 和 activity 中 类似 只不过 要 使用 获取 代码 如下 superoncreate 注册 app 生命周期 观察者 getlifecycle addobserver application 生命周期 观察 提供 整个 应用 进程 的 生命周期 只会 分发 一次 不 会被 分发 第一个 activity 进 入时 将 分派 派 而 将在 最后 一个 activit 退出 后 后 延迟 分发 如果 由于 配置 更改 而 销毁 并重 新创建 活动 则 此 延迟 足以 保证 不会 发送 任何 事件 作用 监听 应用程序 进入 前台 或 后台 logw logw 实现 自定义 lifecycleowner 支持 库 及 更高 版本 中 的 fragment 和 activity 已 实现 lifecycleowner 接口 如果 你 有 一个 自定义 类 并 希望 使其 成为 lifecycleowner 可以 使用 类 但 需 要将 事件 转 发到 该类 代码 如下 superoncreate this superonstart 该 mainactivty 是 实现 了 activity 类 而 不是 类 所以 需要 这样 的 处理 我们 来 看看 中 的 源码 比如 oncreate 方法 和 onpause 方法 b this superonpause 明白 了 基本 的 操作 我们 再看 看看 源码 是 如何 实现 的 注意 本文 不会 仔细 深究 源码 而是 梳理 一个 大概 的 思路 如果 想 要讲 具体 深入 每个 细节 则 可以 照着 我 这个 思路 深入研究 源码 分析 lifecycle 五种 状态 对应 六个 事件 生命周期 首先 我们 来看 lifecycle 这个 类 让 脑子里 面有 一个 大致 的 概念 添加 观察者 移除 观察者 获取 当前 状态 共 五种 状态 weakeraccess publicenumevent 对应 六个 生命周期 方法 还 多个 一个 onany 可以 响应 任何 事件 weakeraccess publicenumstate 五种 状态 对应 生命周期 的 方法 event 方法 returncompareto state gt 如果 你 觉得 还 不够 清楚 只需要 要 记住 五种 状态 对应 六个 生命周期 方法 六个 事件 onany 可以 忽略 然后 我们 再来 看看 官方 的 图 五个 状态 对应 六个 生命周期 方法 六个 事件 这 句话 一 定要 记住 event 表示 生命周期 事件 与 生命周期 方法 对应 state 是 lifecycle 这些 生命周期 对应 的 状态 为什么 不 直接 用 对应 的 生命周期 设置 对应 的 状态 呢 而是 设置 了 五个 状态 呢 原因 很简单 因为 lifecycle 不仅仅 只是 给 自己 用 这些 状态 还有 等 控件 也 会 用到 这些 状态 的 进行 逻辑 判断 所以 google 工程师 做了 更好 的 封装 和 管理 中 的 是 在 lifecyclerowner 对应 的 方法 执行 之后 分发 是 在 lifecyclerowner 对应 的 方法 执行 之前 分发 我们 的 activity 因为 实现 了 lifecycleowner 才能 直接 调用 getlifecycle 从前 面的 分析 我们 可以 看到 是 在 中 实现 了 该 接口 this superoncreate this if setcontentview addobserver myobserver 是 我们 添加 观察者 的 方式 我们 来 看看 addobserver 方法 的 实现 因为 的 实 现是 带 状态 的 观察者 这个 状态 的 作用 新 的 事件 触发 后 遍历 通知 所有 观察者 时 判断 是否 已经 通知 这个 观察者 了 if previousnull if 下面 代码 的 逻辑 通过 while 循环 把 新 的 观察者 的 状态 连续 地 同步 到 最新 状态 mstate 意思 就是 虽然 可能 添加 的 晚 但 把 之前 的 事件 一个个 分发 给你 upevent 方法 即 粘性 observer targetstate observer pushparentstate popparentstate observer if isreentrance 通过 分发 事件 我们 先 来看 observer 分发 通知 观察者 event mstatemin mstatenewstate ownerevent 的 值 为 observer 然后 查看 方法 objectobject object 查看 最后 一行 中 的 objectwrapped 存 放了 注解 方法 的 信息 执行 状态 变化 对应 的 方法 getinfo 的 内容 如下 classklass klass if existingnull klassnull returnexisting 处理 注解 接下来 是 重要 方法 createinfo 在 该 方法 中 进行 注解 的 处理 并 存储 到 mcallbackmap 提供给 后面 的 观察者 调用 createinfo 遍历 方法 处理 注解 将 if superclassnull superclass if superinfonull for for intrfc entrygetvalue klass klass if annotationnull paramslengthgt calltypemethod handlertoevent mcallbackmapput klassinfo returninfo 被 观察者 通知 观察者 观察者 进行 回 调 的 时候 调 用了 的 最终 会调 用到 methodreference 的 invokecallback 方法 mcalltype target targetsource breakcatch catch e 到 这里 观察者 的 注册 和 注解 的 处理 以及 通知 被 观察者 的 流程 就 已经 分析 完毕 了 如何 监听 生命周期 我们 回到 之前 的 的 oncreate 方法 中 可以 看到 调 用了 this 这个 reportfragment 和 glide 中 使用 透明 的 fragment 获取 界面 生命周期 是 一样 的 if null add commit 然后 通过 dispatch 方法 分发 生命周期 dispatchcreate dispatch superonstart dispatchstart dispatch superonresume dispatchresume dispatch superonpause dispatch superonstop dispatch superondestroy dispatch 的 具体 逻辑 如下 最终 都是 调用 来 处理 if activity getlifecycle event returnif lifecycleowner activity getlifecycle if lifecycle event 因为 我们 这里是 所以 来 看看 其 方法 event movetostate next 紧接着 调用 movetostate 方法 statenext if mstatenext 把 生命周期 状态 同步 给 所有 观察者 接着 调用 sync 方法 然后 把 生命周期 同步 给 所有 观察者 if while issynced mstatecompareto getvalue mstate lt backwardpass lifecycleowner if newestgetvalue mstate gt forwardpass lifecycleowner 最 终是 调 用了 forwardpass 方法 然后 调 用了 方法 然后 调用 onstatechanged 方法 后面 的 流程 就和 上面 一样 了 整个 流程 就 结束 了 流程图 整个 流程 还是 比较简单 的 如图所示 处理 onstop 事件 由于 android 系统 版本 的 差异 所以在 依赖 版本 时 需要 注意 可以 参考 官方 的 解释 总结 本文 先从 lifecycle 的 使用 再到 源码 分析 分析 了 观察者 和 被 观察者 的 注册 和 通知 流程 也 分析 了 生命周期 的 监听 的 使用 方式 最后 给出 整体 流程图 喜欢 的 点个 赞 吧 文末 jetpackcompose 是 谷歌 在 googleio 大会上 发布 的 新 的 库 是 用于 构建 原生 androidui 的 现代 工具包 他 有 强大 的 工具 和 直观 的 kotlinapi 简化 并 加速 了 android 上 的 ui 开发 可以 帮助 开发者 用 更少 更 直观 的 代码 创建 view 还有 更 强大 的 功能 以及 还能 提高 开发 速度 客观 地 讲 compose 确 实是 一套 比较 难学 的 东西 因为 它 毕竟 太 新 也 太大 了 它是 一个 完整 的 全新 的 框架 确实 让 很多人 感觉 学 不动 这 也是 个 事实 如果 你 是因为 缺少 学习 资料 而我 正好 薅 到 这本 谷歌 内部 大佬 根 据实 实战 编写 的 jetpackcompose 最全 上手 指南 从 入门 到 精通 教程 通俗易懂 实例 丰富 既有 基础知识 也有 进阶 技能 能够 帮助 读者 快速 入门 是 你 学习 jetpackcompose 的 葵花宝典 快收 藏起来 由于 篇幅 原因 如有 需要 以下 完整 学习 笔记 pdf 可以 点击 我 的 github 免费 下载 获取 第一章 初识 jetpackcompose 为什么 我们 需要 一个 新 的 ui 工具 jetpackcompose 的 着重点 加速 开发 强大 的 ui 工具 直观 的 kotlinapiapi 设计 composeapi 的 原则 一切都是 函数 顶层 函数 组合 优于 继承 信任 单一 来源 深入 了解 插槽 api 第二章 jetpackcompose 构建 最全 上手 指南 jetpackcompose 环境 准备 和 helloworld 布局 使用 materialdesign 设计 compose 布局 实时 预览 深入 详解 jetpackcompose 优化 ui 构建 compose 所 解决 的 问题 composable 函数 剖析 声明 式 ui 组合 vs 继承 封装 重组 深入 详解 jetpackcompose 实现 原理 composable 注解 意味着 什么 执行 模式 位置 记忆 化 存储 参数 重组 第三章 jetpackcompose 项目 实战 演练 附 应用 开始 前 的 准备 创建 demo 遇到 的 问题 jetpackcompose 应用 jetpackcompose 应用 做一个 倒 计时器 数据结构 倒计时 功能 状态 模式 compose 布局 绘制 时钟 用 jetpackcompose 写 一个 玩 安 卓 app 准备工作 引入 依赖 新建 activity 创建 画 页面 底部 导航 栏 管理 状态 添加 页面 用 composeandroid 写 一个 天气 应用 开篇 画 页面 画 背景 画 内容 用 compose 快速 打造 一个 电影 app 成品 实现 方案 实战 不足 由于 篇幅 原因 如有 需要 以上 完整 学习 笔记 pdf 可以 点击 我 的 github 免费 下载 获取 