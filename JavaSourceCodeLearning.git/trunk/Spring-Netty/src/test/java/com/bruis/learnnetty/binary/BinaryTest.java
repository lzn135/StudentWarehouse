package com.bruis.learnnetty.binary;

import org.junit.Test;

/**
 * @author LuoHaiYang
 */
public class BinaryTest {

    /**
     * 对负数的源码、补码和反码进行验证
     */
    @Test
    public void testSingedNumber() {

        /**
         * 1 的二进制：源码    0000 0000 0000 0000 0000 0000 0000 0001
         *            补码    0000 0000 0000 0000 0000 0000 0000 0001
         *  正数的源码和补码相同, 正数没有反码一说，反码是用于计算负数补码的。
         *
         * -1 的二进制：源码   1000 0000 0000 0000 0000 0000 0000 0001
         *             补码   1111 1111 1111 1111 1111 1111 1111 1111
         *             反码   1111 1111 1111 1111 1111 1111 1111 1110
         *
         *  照网上介绍的，二进制的运算都是通过补码来进行的，
         *  那么 1 & -1则为：
         *              0000 0000 0000 0000 0000 0000 0000 0001
         *              由于最高位为0，即为正数，所以该数即为正数。所以补码、源码、反码都一样，所以源码为：
         *              0000 0000 0000 0000 0000 0000 0000 0001  换算为10进制为1。
         *  那么 1 ^ -1则为：
         *              1111 1111 1111 1111 1111 1111 1111 1110
         *  由于上述异运算结果为补码，所以得换回源码之后再计算得十进制结果。
         *  补码：1111 1111 1111 1111 1111 1111 1111 1110
         *  反码计算源码步骤：反码 - 1 ，然后再计算反码
         *  补码 - 1 , 得到的反码为：
         *  1111 1111 1111 1111 1111 1111 1111 1101
         *  用上述反码计算源码得：
         *  1000 0000 0000 0000 0000 0000 0000 0010
         *
         *  由于最高位为1，即为负数，所以结果为2。
         *
         *  则 1 | -1 可以计算结果为：
         *              1111 1111 1111 1111 1111 1111 1111 1111
         *  反码：
         *  1111 1111 1111 1111 1111 1111 1111 1110
         *  源码：
         *  1000 0000 0000 0000 0000 0000 0000 0001
         *
         */
        int a = 1, b = -1;

        // 1
        System.out.println(a & b);
        // -2
        System.out.println(a ^ b);
        // -1
        System.out.println(a | b);

    }

    @Test
    public void testSingedNumber2() {

        /**
         * 分析：
         * 10
         *    源码：0000 0000 0000 0000 0000 0000 0000 1010
         *    补码：0000 0000 0000 0000 0000 0000 0000 1010
         *
         * -10
         *    源码：0000 0000 0000 0000 0000 0000 0000 1010
         *    反码：1111 1111 1111 1111 1111 1111 1111 0101
         *    补码：1111 1111 1111 1111 1111 1111 1111 0110
         *
         * a & b
         *    补码：0000 0000 0000 0000 0000 0000 0000 0010
         *    反码：0000 0000 0000 0000 0000 0000 0000 0010
         *    源码：0000 0000 0000 0000 0000 0000 0000 0010
         *
         * a ^ b
         *    补码：0000 0000 0000 0000 0000 0000 0000 0010
         *    反码：0000 0000 0000 0000 0000 0000 0000 0010
         *    源码：0000 0000 0000 0000 0000 0000 0000 0010
         *
         */
        int a = 10, b = -10;


        System.out.println(a & b);
        System.out.println(a ^ b);
        System.out.println(a | b);
    }

    /**
     * 测试移位运算
     */
    @Test
    public void testMove() {

        int a = 16, b = -16;

        /**
         * a = 16, 其二进制源码为：
         * 0000 0000 0000 0000 0000 0000 0001 0000
         * 其反码和补码和源码都相同。
         *
         * b = -16, 其二进制源码为：
         * 1000 0000 0000 0000 0000 0000 0001 0000
         * 反码：
         * 1111 1111 1111 1111 1111 1111 1110 1111
         * 补码：
         * 1111 1111 1111 1111 1111 1111 1111 0000
         *
         * -16 << 2 , 对补码进行向左移2位, 低位补0
         * 1111 1111 1111 1111 1111 1111 1100 0000
         * 由于移位后最高位仍然为1，表示负数，所以需要借助反码来运算
         *
         * 反码为补码 - 1，则结果为：
         * 1111 1111 1111 1111 1111 1111 1011 1111
         *
         * 源码为反码取反，则结果为：
         * 1000 0000 0000 0000 0000 0000 0100 0000
         * -1 * (2 * 2 ^ 6) = -64
         *
         * -16 >> 2
         * -16
         * 源码：1000 0000 0000 0000 0000 0000 0001 0000
         * 补码：1111 1111 1111 1111 1111 1111 1111 0000
         *
         * 对补码进行向右有符号移2位后，结果(补码)为：
         * 111 1111 1111 1111 1111 1111 1111 1100
         *
         * 反码为补码 - 1， 则对移位后的结果进行运算，得：
         * 1111 1111 1111 1111 1111 1111 1111 1011
         * 源码得：
         * 1000 0000 0000 0000 0000 0000 0000 0100
         *
         * 结果为-4。
         *
         */
        System.out.println(a << 2);
        System.out.println(b << 2);

        System.out.println(a >> 2);
        System.out.println(b >> 2);

        System.out.println(a >>> 2);
        System.out.println(b >>> 2);
    }
}
